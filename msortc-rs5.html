<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Microsoft Object RTC (ORTC) Implementation</title>
    <meta charset='utf-8'>
  <script src="respec-w3c-common.js" async class="remove"></script>
  <script src="respec-config.js" class="remove"></script>
  </head>
<body>
<section id="abstract">
<p>This document describes enhancements to the Microsoft Edge ORTC API under consideration for future
releases of Windows 10.  Since these enhancements have not been approved for implementation, they
are by nature speculative, and may not be implemented in present or future
Windows Insider Preview builds.</p>
<p>The Microsoft Edge ORTC API implementation differs from the most recent version of the
<a href="http://draft.ortc.org/">ORTC API</a> since ORTC has continued to evolve since the development of
Microsoft Edge got underway.  In addition, Microsoft Edge does not implement every object or method
within the ORTC API, and includes some extensions not currently incorporated within the specification.
Since both Microsoft Edge and this document represent works-in-progress, the behavior of Microsoft Edge can
change substantially from build-to-build.  Please bring questions, errors and omissions to the attention of the
Edge RTC team (Bernard Aboba, bernarda@microsoft and Shijun Sun, shijuns@microsoft.com). 
</p>
</section>

<section id='sotd'>
</section>

<section id="overview*">

  <h2><span class="secno"> </span>Overview</h2>

<p>Microsoft's Object Real-Time Communications (ORTC) API implementation enables the development of realtime communications applications. 
Within Microsoft's implementation, 
the relationship between the application and the objects, as well 
as between the objects themselves is shown below. 
Horizontal or slanted arrows denote the flow of media or data, 
whereas vertical arrows denote interactions via methods and events. 
</p>

<img alt="The non-normative ORTC Big Picture Diagram" src="images/msortc-big-picture-revised.svg" style="width:100%" />

<p>In the figure above, the <code><a>RTCRtpSender</a></code> (<a href="#rtcrtpsender*">Section 6</a>) encodes the
track provided as input, which is transported over a <code><a>RTCDtlsTransport</a></code>
(<a href="#rtcdtlstransport*">Section 4</a>) or an <code><a>RTCSrtpSdesTransport</a></code>
(<a href="#rtcsrtpsdestransport*">Section 5</a>).</p>
<p>The <code><a>RTCDtlsTransport</a></code> and <code><a>RTCSrtpSdesTransport</a></code> utilize an <code><a>RTCIceTransport</a></code>
(<a href="#rtcicetransport*">Section 3</a>) to select a communication path to reach the
receiving peer's <code><a>RTCIceTransport</a></code>, which is in turn associated with 
an <code><a>RTCDtlsTransport</a></code> or <code><a>RTCSrtpSdesTransport</a></code> which de-multiplexes
media to the <code><a>RTCRtpReceiver</a></code> (<a href="#rtcrtpreceiver*">Section 7</a>).
The <code><a>RTCRtpReceiver</a></code> then decodes media, producing a track which is rendered 
by an audio or video tag.</p>
<p>Several other objects also play a role.
The <code><a>RTCIceGatherer</a></code> (<a href="#rtcicegatherer*">Section 2</a>)
gathers local ICE candidates for use by a single
<code><a>RTCIceTransport</a></code> object. The <code><a>MSRTCConfConfig</a></code>
(<a href="#msrtcconfconfig*">Section 8</a>) configures <code><a>RTCIceGatherer</a></code> objects.
Sending of Dual Tone Multi Frequency (DTMF) tones is supported via the
<code><a>RTCDtmfSender</a></code> (<a href="#rtcdtmfsender*">Section 10</a>).</p> 
<p>Remaining sections of the specification fill in details relating to RTP capabilities and parameters, 
operational statistics and compatibility with the
WebRTC 1.0 API.  
RTP dictionaries are described in <a href="#rtcrtpdictionaries*">Section 9</a>,
the Statistics API is described in <a href="#statistics-api">Section 11</a>,
Microsoft extensions related to the H.264UC codec [[MS-H264PF]] and statistics are described in
<a href="#msextensions*">Section 12</a>,
an event summary is provided in <a href="#event-summary">Section 13</a>,
a list of error codes is provided in <a href="#error-codes*">Section 14</a>
and WebRTC 1.0 compatibility issues are discussed in <a href="#webrtc-compat*">Section 15</a>.</p>
<p>Complete examples are provided in <a href="#examples*">Section 16</a>.</p>
<div class="note">
<p>Edge Interop Note:  Since Microsoft Edge does not implement the data channel,
the <code>RTCDataChannel</code> and <code>RTCSctpTransport</code> objects are not supported.</p>
</div>

  <section>
    <h3>Terminology</h3>

    <p>The <code><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
    interface represents a callback used for event handlers as defined in
    [[!HTML5]].</p>

    <p>The concepts <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a
    task</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a
    simple event</a></dfn> are defined in [[!HTML5]].</p>

    <p>The terms <dfn>event</dfn>, <dfn><a href=
    "http://dev.w2.org/html5/spec/webappapis.html#event-handlers">event
    handlers</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
    handler event types</a></dfn> are defined in [[!HTML5]].</p>

    <p>The terms <dfn>MediaStream</dfn> and <dfn>MediaStreamTrack</dfn>
    are defined in
    [[!GETUSERMEDIA]].</p>

    <p>For Scalable Video Coding (SVC), the terms single-session transmission (<dfn>SST</dfn>) and multi-session transmission (<dfn>MST</dfn>)
    are defined in [[RFC6190]].  This specification only supports <a>SST</a> but not <a>MST</a>.  
    The term Single Real-time transport protocol stream Single Transport  (<dfn>SRST</dfn>), 
    defined in [[RFC7656]] Section 3.7, refers to an SVC implementation that transmits all layers within a
    single transport, using a single Real-time Transport Protocol (RTP) stream and synchronization source (SSRC).
    The term Multiple RTP stream Single Transport (<dfn>MRST</dfn>), also defined in [[RFC7656]] Section 3.7,  refers
    to an implementation that transmits all layers within a single transport, using multiple RTP streams with
    a distinct SSRC for each layer.</p>
  </section>
  </section>

  <section id="rtcicegatherer*">
    <h2><dfn>RTCIceGatherer</dfn> Interface</h2>

    <p>
      The <code>RTCIceGatherer</code> gathers local host, server reflexive and relay candidates, as 
      well as enabling the retrieval of local Interactive Connectivity Establishment (ICE) parameters which can be exchanged in signaling. 
    </p>

  <section id="rtcicegatherer-overview*">
    <h3>Overview</h3>
<p>The Microsoft Edge implementation of the <code><a>RTCIceGatherer</a></code> does not support
the <var>component</var> or <var>state</var> attributes, nor does it support the
<code>close()</code> method or the <code>ongatherstatechange</code> event handler. 
</p>

      <div class="note">
<p>Edge Interop Note: In the Microsoft Edge implementation, an <code><a>RTCIceGatherer</a></code> instance can only
be associated to a single <code><a>RTCIceTransport</a></code>
object.  As a result, forking scenarios are not supported.
The <code><a>RTCIceGatherer</a></code> prunes local candidates when its
associated <code><a>RTCIceTransport</a></code> object enters the "completed" state.
</p>
      </div>

<p>As noted in [[!RFC5245]] Section 7.1.2.2, an incoming connectivity check contains an <code>ICE-CONTROLLING</code>
or <code>ICE-CONTROLLED</code> attribute, depending on the role of the ICE agent initiating the check.
Since an <code><a>RTCIceGatherer</a></code> object does not have a role, it cannot determine whether
to respond to an incoming connectivity check with a 487 (Role Conflict) error; however, it can validate
that an incoming connectivity check utilizes the correct local username fragment and password, 
and if not, can respond with an
401 (Unauthorized) error, as described in [[!RFC5389]] Section 10.1.2.</p>
<p>For incoming connectivity checks that pass validation, the <code><a>RTCIceGatherer</a></code>
<em class="rfc2119" title="MUST">MUST</em>
buffer incoming connectivity checks so as to be able to provide them to associated
<code><a>RTCIceTransport</a></code> objects so that they can respond.</p> 
  </section>

  <section id="rtcicegatherer-operation*">
    <h3>Operation</h3>

    <p>An <code><a>RTCIceGatherer</a></code> instance is constructed from an
    <code><a>RTCIceGatherOptions</a></code> object and an optional <code><a>MSRTCConfConfig</a></code> object.
 .  If <code><a>RTCIceGatherOptions</a>.portRange</code>
    is invalid (e.g. <code>portRange.max</code> &lt; <code>portRange.min</code>), 
    throw an <code>InvalidParameters</code> exception.</p>
  </section>

  <section id="rtcicegatherer-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCIceGatherOptions options, optional MSRTCConfConfig config)] interface RTCIceGatherer : RTCStatsProvider">
      <dt>readonly attribute RTCIceComponent component</dt>
      <dd><p>The component-id of the <code><a>RTCIceGatherer</a></code>.</p></dd>
      <dt>RTCIceParameters getLocalParameters()</dt>
      <dd><p>Obtain the ICE parameters of the <code><a>RTCIceGatherer</a></code>.</p></dd>
      <dt>sequence&lt;RTCIceCandidate>  getLocalCandidates()</dt>
      <dd><p>Retrieve the sequence of valid local candidates associated with the
      <code><a>RTCIceGatherer</a></code>.
      This retrieves all unpruned local candidates currently known (except for peer reflexive candidates),
      even if an <code><a>onlocalcandidate</a></code>
      event hasn't been processed yet.  In Microsoft Edge, if <code>getLocalCandidates()</code> is called prior to emitting of the
      first candidate, an exception is thrown. 
      </p></dd>

      <dt>RTCIceGatherer createAssociatedGatherer()</dt>
      <dd><p>Create an associated <code><a>RTCIceGatherer</a></code> for RTCP, with the same 
      <code><a>RTCIceParameters</a></code> and <code><a>RTCIceGatherOptions</a></code>.
      If an <code><a>RTCIceGatherer</a></code> calls the method more than once, 
      or if <var>component</var> is "RTCP", throw 
      an <code>InvalidStateError</code> exception.
      </p></dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>,
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects 
      implementing the <code><a>RTCIceGatherer</a></code> interface.
      If TURN credentials are invalid, or a port cannot be allocated for a local ICE candidate, then this event <em class="rfc2119" title="MUST">MUST</em>
      be fired.
      </p></dd>

      <dt>attribute EventHandler? onlocalcandidate</dt>
      <dd><p>This event handler, of event handler event type <code>icecandidate</code>, uses
      the <code><a>RTCIceGathererEvent</a></code> interface.
      It <em class="rfc2119" title="MUST">MUST</em>  be supported by all objects implementing the
      <code><a>RTCIceGatherer</a></code> interface.
      It receives events when a new local ICE candidate is available.  Since ICE candidate gathering begins once
      an <code><a>RTCIceGatherer</a></code> object is created,
      <code>candidate</code> events are queued until an <code>onlocalcandidate</code> event handler is assigned.
      When the final candidate is gathered, a <code>candidate</code> event occurs with an <code>RTCIceCandidateComplete</code> emitted.
    </p></dd>
    </dl>
  </section>

  <section id="rtciceparameters*">
   <h3><dfn>RTCIceParameters</dfn> Dictionary</h3>

   <p>
     The <code>RTCIceParameters</code> dictionary includes the ICE username fragment and password, as well as an indication of whether ICE lite is supported.
   </p>

    <dl class="idl" title="dictionary RTCIceParameters">
      <dt>DOMString usernameFragment</dt>
      <dd><p>ICE username.</p></dd>
      <dt>DOMString password</dt>
      <dd><p>ICE password.</p></dd>
      <dt>boolean? iceLite</dt>
      <dd>Whether ICE lite is supported (true) or not (false).  If unset, ICE lite is not supported.
      Since browsers support full ICE, <code>getLocalParameters().iceLite</code> MUST NOT be set.  This
      attribute is only set in remote parameters signaled by a remote peer (such as a gateway) that only supports ICE lite.</dd>
    </dl>
  </section>

  <section id="rtcicecandidate*">
    <h3><dfn>RTCIceCandidate</dfn> Dictionary</h3>

    <p>
      The <code>RTCIceCandidate</code> dictiontary includes information relating to an ICE candidate.
    </p>

   <pre xml:space="preserve" class='example highlight'>
  foundation: "abcd1234",
  priority: 1694498815,
  ip: "192.0.2.33",
  protocol: "udp",
  port: 10000,
  type: "host"
};
    </pre>

     <dl class="idl" title="typedef (RTCIceCandidate or RTCIceCandidateComplete) RTCIceGatherCandidate">
     </dl>

    <dl class="idl" title="dictionary RTCIceCandidate">
      <dt>DOMString foundation</dt>
      <dd>
        <p>A unique identifier that allows ICE to correlate candidates that appear on multiple <code><a>RTCIceTransport</a></code>s.</p>
      </dd>
      <dt>unsigned long priority</dt>
      <dd><p>The assigned priority of the candidate.  This is automatically populated by the browser.</p></dd>
      <dt>DOMString ip</dt>
      <dd><p>The IP address of the candidate.</p></dd>
      <dt>RTCIceProtocol protocol</dt>
      <dd><p>The protocol of the candidate (UDP/TCP).</p></dd>
      <dt>unsigned short port</dt>
      <dd><p>The port for the candidate.</p></dd>
      <dt>DOMString interfaceType</dt>
      <dd><p>The interface type for the candidate.  Types include "lan", "wlan", "wwan" and "vpn".
      Not supported in Microsoft Edge.</p></dd>
      <dt>RTCIceCandidateType type</dt>
      <dd><p>The type of candidate.</p></dd>
      <dt>RTCIceTcpCandidateType tcpType=null</dt>
      <dd><p>The type of TCP candidate.</p></dd>
      <dt>DOMString relatedAddress=""</dt>
      <dd>
        <p>For candidates that are derived from others, such as relay or reflexive candidates, the <dfn>relatedAddress</dfn>
        refers to the candidate that these are derived from.  For host candidates, the <var>relatedAddress</var>
        is set to the empty string.</p>
      </dd>
      <dt>unsigned short relatedPort=null</dt>
      <dd>
        <p>For candidates that are derived from others, such as relay or reflexive candidates, the <dfn>relatedPort</dfn>
        refers to the host candidate that these are derived from.  For host candidates, the <var>relatedPort</var>
        is null.</p>
      </dd>
      <dt>DOMString msMTurnSessionId</dt>
      <dd><p>The assigned MTURN session identifier of the candidate. This is only set when an MSTURN URI is provided in the <code><a>RTCIceServer</a></code> object.</p></dd>
    </dl>

   <section>
      <h4><dfn>RTCIceProtocol</dfn> Enum</h4>
      <p>
        The <code>RTCIceProtocol</code> provides the protocol of the ICE candidate.
      </p>
      <dl class="idl" title="enum RTCIceProtocol">
        <dt>udp</dt>
        <dd><p>A UDP candidate, as described in [[!RFC5245]].</p></dd>
        <dt>tcp</dt>
        <dd><p>A TCP candidate, as described in [[!RFC6544]].</p></dd>
      </dl>
    </section>

    <section>
      <h4><dfn>RTCIceTcpCandidateType</dfn> Enum</h4>
      <p>
        The <code>RTCIceTcpCandidateType</code> provides the type of the ICE TCP candidate, as described in [[!RFC6544]].
        Browsers MUST gather active TCP candidates and only active TCP candidates.
        Servers and other endpoints MAY gather active, passive or so candidates.
      </p>
      <dl class="idl" title="enum RTCIceTcpCandidateType">
        <dt>active</dt>
        <dd><p>An active TCP candidate is one for which the transport will
   attempt to open an outbound connection but will not receive incoming
   connection requests.</p></dd>
        <dt>passive</dt>
        <dd><p>A passive TCP candidate is one for which the transport
   will receive incoming connection attempts but not attempt a
   connection.</p></dd>
        <dt>so</dt>
        <dd><p>An so candidate is one for which the transport will attempt
   to open a connection simultaneously with its peer.</p></dd>
      </dl>
    </section>

    <section>
    <h4><dfn>RTCIceCandidateType</dfn> Enum</h4>
      <p>
        The <code>RTCIceCandidateType</code> provides the type of the ICE candidate.
      </p>
      <dl class="idl" title="enum RTCIceCandidateType">
        <dt>host</dt>
        <dd><p>A host candidate.</p></dd>
        <dt>srflx</dt>
        <dd><p>A server reflexive candidate.</p></dd>
        <dt>prflx</dt>
        <dd><p>A peer reflexive candidate.</p></dd>
        <dt>relay</dt>
        <dd><p>A relay candidate.</p></dd>
      </dl>
    </section>
  </section>

  <section id="rtcicecandidatecomplete*">
    <h3><dfn>RTCIceCandidateComplete</dfn> Dictionary</h3>

   <p>
    The <code>RTCIceCandidateComplete</code> dictionary signifies that all <code>RTCIceCandidate</code>s are gathered.
   <p>

    <dl class="idl" title="dictionary RTCIceCandidateComplete">
    </dl>
  </section>

      <section>
        <h4>RTCIceGathererEvent</h4>

        <p>The <code>icecandidate</code> event of the <code><a>RTCIceGatherer</a></code> object uses
        the <code><a>RTCIceGathererEvent</a></code> interface.</p>
        <p>Firing an
        <code><a>RTCIceGathererEvent</a></code> event named
        <var>e</var> with an <code><a>RTCIceGatherCandidate</a></code>
        <var>candidate</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code><a>RTCIceGathererEvent</a></code> interface with the
        <var>candidate</var> attribute set to the new ICE candidate,
       <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="RTCIceGathererEventInit" title=
        "[Constructor(DOMString type, RTCIceGathererEventInit eventInitDict)] interface RTCIceGathererEvent : Event">

          <dt>readonly attribute RTCIceGatherCandidate candidate</dt>

          <dd>
            <p>The <var>candidate</var> attribute is the
            <code><a>RTCIceGatherCandidate</a></code> object with the new ICE
            candidate that caused the event.
             If <var>candidate</var> is of type <code>RTCIceCandidateComplete</code>,
             there are no additional candidates.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary RTCIceGathererEventInit : EventInit">
          <dt>RTCIceGatherCandidate candidate</dt>
          <dd>
            <p>The ICE candidate that caused the event.</p>
          </dd>
        </dl>
      </section>

  <section id="rtcicegatheroptions*">
   <h3><dfn>RTCIceGatherOptions</dfn> Dictionary</h3>
   <p><code>RTCIceGatherOptions</code> provides options relating to the gathering of ICE candidates.</p>

        <dl class="idl" title=
        "dictionary RTCIceGatherOptions">
          <dt>RTCIceGatherPolicy gatherPolicy</dt>
          <dd><p>The ICE gather policy.</p></dd>
          <dt>sequence&lt;RTCIceServer> iceservers</dt>
          <dd><p>The ICE servers to be configured.</p></dd>
          <dt>MSPortRange portRange</dt>
          <dd><p>The port range to use for local candidates</p></dd>
        </dl>
  </section>

<section id="msportrange*">
<h3><dfn>MSPortRange</dfn> Dictionary</h3>
<dl title='dictionary MSPortRange' class='idl'>
<dt>unsigned short min</dt>
<dd><p>Beginning of the port range.</p></dd>
<dt>unsigned short max</dt>
<dd><p>End of the port range.</p></dd>
</dl>
</section>

  <section id="rtcicegatherpolicy*">
  <h3><dfn>RTCIceGatherPolicy</dfn> Enum</h3>
    <p>The <code>RTCIceGatherPolicy</code> dictoinary provides the policy relating to the gathering of ICE candidates.</p>
    <dl class="idl" title="enum RTCIceGatherPolicy">
      <dt>all</dt>
      <dd><p>The ICE gatherer gathers all types of candidates when this value is specified.</p></dd>
      <dt>nohost</dt>
      <dd><p>The ICE gatherer gathers all ICE candidate types except for host candidates.</p></dd>
      <dt>relay</dt>
      <dd><p>The ICE gatherer <em class="rfc2119" title="MUST">MUST</em> only gather media relay
      candidates such as candidates passing through a TURN server. This can be used to reduce
      leakage of IP addresses in certain use cases.</p></dd>
    </dl>
  </section>

  <section id="rtciceserver*">
  <h3><dfn>RTCIceServer</dfn> Dictionary</h3>

   <p>
    The <code>RTCIceServer</code> dictionary provides STUN or TURN server configuration.
    In network topologies with multiple layers of NATs, it is desirable to have a STUN server
    between every layer of NATs in addition to the TURN servers to minimize the peer to peer network latency.
   <p>

   </p>
     An example of an array of <code<<a>RTCIceServer</a></code> objects supporting the STUN and TURN standards:
   </p>

   <pre xml:space="preserve" class='example highlight'>
      [ { urls: "stun:stun1.example.net" } , 
        { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} 
      ]
   </pre>

   </p>
     An example of an array of <code<<a>RTCIceServer</a></code> objects supporting [[MS-TURN]]:
   </p>

   <pre xml:space="preserve" class='example highlight'>
      [ { urls: "stun:stun1.example.net" } , 
        { urls:"msturn:turn.example.org", username: "user", credential:"myPassword"},
        { urls:"msturn-v2:turn2.example.org", username: "user", credential:"myPassword"}
      ]
   </pre>

      <div class="note">
<p>Edge Interop Note:  Inclusion of the MSTURN or MSTURN-V2 URI triggers use of a proprietary TURN variant described in [[MS-TURN]], as well as proprietary ICE behavior
described in [[MS-ICE]] and [[MS-ICE2]].
The MSTURN or MSTURN-V2 URI should therefore not be used in scenarios requiring interoperability with other browsers.
The STUN URI is not currently supported. 
</p>
      </div>

    <dl class="idl" title="dictionary RTCIceServer">
      <dt>(DOMString or sequence&lt;DOMString>) urls</dt>
      <dd><p>STUN or TURN URI(s) as defined in [[!RFC7064]] and [[!RFC7065]] or other URI types (such as the MSTURN URI, described in [[MS-TURN]]).</p></dd>
      <dt>DOMString username</dt>
      <dd><p>If this <code><a>RTCIceServer</a></code> object represents a TURN server, then this attribute specifies
      the username to use with that TURN server.</p></dd>
      <dt>DOMString credential</dt>
      <dd><p>If this <code><a>RTCIceServer</a></code> represents a TURN server, then this attribute specifies the credential to use with that TURN server.</p></dd>
    </dl>
  </section>

  <section id="rtcicegatherer-initial-example*">
    <h3>Example</h3>

   <pre xml:space="preserve" class='example highlight'>
// Include some helper functions
import "helper.js";
// Create ICE gather options
var gatherOptions = new RTCIceGatherOptions();
gatherOptions.gatherPolicy = RTCIceGatherPolicy.relay;
gatherOptions.iceservers = [ { urls: "stun:stun1.example.net" } , 
  { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} ];
// Create ICE gatherer objects
var iceGatherer = new RTCIceGatherer(gatherOptions);
// Prepare to signal local candidates as well as "end of candidates"
iceGatherer.onlocalcandidate = function (event) {
  mySendLocalCandidate(event.candidate);
}; 
// Set up response function
mySignaller.onResponse = function(responseSignaller,response) {
  // The Microsoft Edge ORTC implementation only supports a single response. 
};

mySignaller.send({
   "ice": iceGatherer.getLocalParameters()
});
</pre>
   <pre xml:space="preserve" class='example highlight'>
// Helper functions used in all the examples (helper.js)
function trace(text) {
  // This function is used for logging.
  if (text[text.length - 1] === '\n') {
    text = text.substring(0, text.length - 1);
  }
  if (window.performance) {
    var now = (window.performance.now() / 1000).toFixed(3);
    console.log(now + ': ' + text);
  } else {
    console.log(text);
  }
}

function errorHandler (error) {
  trace('Error encountered: ' + error.name);
}

function mySendLocalCandidate(candidate, component, kind){
  // Set default values
  kind = kind || "all";
  component = component || RTCIceComponent.RTP;
  parameters = parameters || null; 
  // Signal the local candidate 
  mySignaller.mySendLocalCandidate({
  "candidate": candidate,
  "component": component,
  "kind": kind
  });
}

function myIceTransportStateChange(name, state){
  switch(state){
  case RTCIceTransportState.new:
     trace('IceTransport: ' + name + ' Has been created');
     break;
  case RTCIceTransportState.checking:
     trace('IceTransport: ' + name + ' Is checking');
     break;
  case RTCIceTransportState.connected:
     trace('IceTransport: ' + name + ' Is connected');
     break;
  case RTCIceTransportState.disconnected:
     trace('IceTransport: ' + name + ' Is disconnected');
     break;
  case RTCIceTransportState.completed:
     trace('IceTransport: ' + name + ' Has finished checking (for now)');
     break;
  case RTCIceTransportState.closed:
     trace('IceTransport: ' + name + ' Is closed');
     break;
  default:
     trace('IceTransport: ' + name + ' Invalid state');
  }
}

function myDtlsTransportStateChange(name, state){
  switch(state){
  case RTCDtlsTransportState.new:
     trace('DtlsTransport: ' + name + ' Has been created');
     break;
  case RTCDtlsTransportState.connecting:
     trace('DtlsTransport: ' + name + ' Is connecting');
     break;
  case RTCDtlsTransportState.connected:
     trace('DtlsTransport: ' + name + ' Is connected');
     break;
  case RTCDtlsTransportState.closed:
     trace('DtlsTransport: ' + name + ' Is closed');
     break;
  default:
     trace('DtlsTransport: ' + name + ' Invalid state');
  }
}
 </pre>
  </section>

</section>

<section id="rtcicetransport*">
 <h2><dfn>RTCIceTransport</dfn> Interface</h2>

    <p>
      The <code>RTCIceTransport</code> includes information relating to Interactive Connectivity Establishment (ICE).
    </p>

  <section id="rtcicetransport-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCIceTransport</a></code> instance is associated to a transport object (such as <code><a>RTCDtlsTransport</a></code>), 
       and provides RTC related methods to it.  The Microsoft Edge implementation does not support the <code>oncandidatepairchange</code>
       event handler.</p>  

      <div class="note">
<p>Edge Interop Note: The Microsoft Edge ICE implementation only supports regular nomination.  In connectivity checks that it sends, Edge will
only set the USE-CANDIDATE flag for the selected pair.  Also, Edge will only respond to the first connectivity check setting the
USE-CANDIDATE flag, and will ignore all subsequent connectivity checks with the USE-CANDIDATE flag set.</p>
      </div>

  </section>

  <section id="rtcicetransport-operation*">
    <h3>Operation</h3>

    <p>An <code><a>RTCIceTransport</a></code> instance is constructed from an optional <code><a>RTCIceGatherer</a></code> object.</p> 
  </section>

  <section id="rtcicetransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(optional RTCIceGatherer gatherer)] interface RTCIceTransport : RTCStatsProvider">
      <dt>readonly attribute RTCIceGatherer? iceGatherer</dt>
      <dd><p>
      The <var>iceGatherer</var> attribute is set to the value of <var>gatherer</var> passed in the constructor or the
      latest call to <code>start()</code>. 
      </p></dd>
      <dt>readonly attribute RTCIceRole role</dt>
      <dd><p>The current role of the ICE transport.</p></dd>
      <dt>readonly attribute RTCIceComponent component</dt>
      <dd><p>The component-id of the <code><a>RTCIceTransport</a></code>.</p></dd>
      <dt>readonly attribute RTCIceTransportState state</dt>
      <dd><p>The current state of the ICE transport.</p></dd>
      <dt>sequence&lt;RTCIceCandidate> getRemoteCandidates()</dt>
      <dd><p>Retrieve the sequence of candidates associated with the remote 
      <code><a>RTCIceTransport</a></code>.  Only returns the candidates previously
      added using <code>setRemoteCandidates()</code> or <code>addRemoteCandidate()</code>.</p></dd>

      <dt>RTCIceCandidatePair? getNominatedCandidatePair()</dt>
      <dd><p>Retrieves the selected candidate pair on which media is flowing.  If there is no selected pair yet, 
      or consent is lost on the selected pair, NULL is returned.
      </p></dd>

      <dt>void start(RTCIceGatherer gatherer, RTCIceParameters remoteParameters, optional RTCIceRole role)</dt>
      <dd><p>The first time <code>start()</code> is called, candidate connectivity checks are started and the 
      ICE transport attempts to connect to the remote <code><a>RTCIceTransport</a></code>.
      If <code>remoteParameters.iceLite</code> is "true" then the remote peer supports ICE lite; if it is "false" or unset
      then the remote peer supports full ICE.
      If <code>start()</code> is called with invalid parameters, throw an <code>InvalidParameters</code> exception.
      For example, if <var>gatherer.component</var>
      has a value different from <var>iceTransport.component</var>, throw an <code>InvalidParameters</code> exception.
      If <var>state</var> is "closed", 
      throw an <code>InvalidStateError</code> exception. 
      When <code>start()</code> is called again, <code><a>RTCIceTransportState</a></code> transitions to the "connected" state,
      all remote candidates are flushed, and <code>addRemoteCandidate()</code> or
      <code>setRemoteCandidates()</code> must be called to add the remote candidates back or replace them.</p><p>
      If <code>start()</code>
      is called again, an <code>InvalidStateError</code> exception is thrown. 
      </p>
<p>As noted in [[!RFC5245]] Section 7.1.2.3, an incoming connectivity check utilizes the local/remote username fragment
and the local password, whereas an outgoing connectivity check utilizes the local/remote username fragment and the
remote password.  Since <code>start()</code> provides role information, as well as the remote username fragment and password, 
once <code>start()</code> is called an <code><a>RTCIceTransport</a></code> object
can respond to incoming connectivity checks based on its configured role, as well as initiating connectivity checks.</p>
</dd>

      <dt>void stop()</dt>
      <dd><p>Stops and closes the current object.  
      Calling <code>stop()</code> when <var>state</var> is "closed" has no effect.
      </p></dd>

      <dt>RTCIceParameters? getRemoteParameters()</dt>
      <dd><p>Obtain the current ICE parameters of the remote <code><a>RTCIceTransport</a></code>.</p></dd>

      <dt>RTCIceTransport createAssociatedTransport ()</dt>
      <dd><p>Create an associated <code><a>RTCIceTransport</a></code> for RTCP.
      If called more than once for the same component, or if <var>state</var> is "closed", 
      throw an <code>InvalidStateError</code>  exception.  If called when 
      <var>component</var> is "RTCP",
      throw an <code>InvalidStateError</code> exception. 
      </p></dd>

      <dt>void addRemoteCandidate(RTCIceGatherCandidate remoteCandidate)</dt>
      <dd><p>Add a remote candidate associated with the remote <code><a>RTCIceTransport</a></code>.
      If <var>state</var> is "closed", throw an <code>InvalidStateError</code> exception.
      Since Microsoft Edge only supports "half-trickle", Edge will not begin candidate pair checks until <code>RTCIceComplete</code>
      has been passed as an argument to <code>addRemoteCandidate()</code>.
      </p></dd>

      <dt>void setRemoteCandidates(sequence&lt;RTCIceCandidate> remoteCandidates)</dt>
      <dd><p>Set the sequence of candidates associated with the remote <code><a>RTCIceTransport</a></code>.
      If <var>state</var> is "closed", throw an <code>InvalidStateError</code> exception.
      </p></dd>

      <dt>attribute EventHandler? onicestatechange</dt>
      <dd><p>This event handler, of event handler type <code>icestatechange</code>, 
      uses the <code>RTCIceTransportStateChangedEvent</code> interface.
      It <em class="rfc2119" title="MUST">MUST</em> be supported by
      all objects implementing the <code><a>RTCIceTransport</a></code> interface.
      It is called any time the <code><a>RTCIceTransportState</a></code> changes.
      <p></dd>

    </dl>
  </section>

  <section id="rtcicecomponent*">
  <h3><dfn>RTCIceComponent</dfn> Enum</h3>
    <p><code>RTCIceComponent</code> provides the component-id of the <code><a>RTCIceTransport</a></code>, which will be "RTP" unless RTP and RTCP are not multiplexed and
      the <code><a>RTCIceTransport</a></code> object was returned by <code>createAssociatedTransport()</code>.</p>
    <dl class="idl" title="enum RTCIceComponent">
      <dt>RTP</dt>
      <dd><p>The RTP component ID, defined (as '1') in [[!RFC5245]] Section 4.1.1.1.
      </p></dd>
      <dt>RTCP</dt>
      <dd><p>The RTCP component ID, defined (as '2') in [[!RFC5245]] Section 4.1.1.1.</p></dd>
    </dl>
  </section>

  <section id="rtcicerole*">
  <h3><dfn>RTCIceRole</dfn> Enum</h3>
    <p><code>RTCIceRole</code> contains the current role of the ICE transport.</p>
    <dl class="idl" title="enum RTCIceRole">
      <dt>controlling</dt>
      <dd><p>controlling state</p></dd>

      <dt>controlled</dt>
      <dd><p>controlled state</p></dd>
    </dl>
  </section>

  <section id="rtcicetransportstate*">
  <h3><dfn>RTCIceTransportState</dfn> Enum</h3>
    <p><code>RTCIceTransportState</code> represents the current state of the ICE transport.</p>
    <dl class="idl" title="enum RTCIceTransportState">
      <dt>new</dt>
      <dd><p>The <code><a>RTCIceTransport</a></code> object is waiting for remote candidates to be supplied.
      In this state the object can respond to incoming connectivity checks.
      </p></dd>

      <dt>checking</dt>
      <dd><p>
      The <code><a>RTCIceTransport</a></code> has received at least one remote candidate,
      and a local and remote <code><a>RTCIceCandidateComplete</a></code> dictionary was not added as the last candidate.
      In this state the <code><a>RTCIceTransport</a></code> is checking candidate pairs but has not yet found a
      successful candidate pair, or liveness checks have failed (such as those in [[!RFC7675]]) on
      a previously successful candidate pair.
      </p></dd>

      <dt>connected</dt>
      <dd><p>The <code><a>RTCIceTransport</a></code> has received a response to an outgoing connectivity check, or has received incoming DTLS/media after
      a successful response to an incoming connectivity check, 
      but is still checking other candidate pairs to see if there is a better connection. 
      In this state outgoing media is permitted.</p></dd>

      <dt>completed</dt>
      <dd><p>
     A local and remote <code><a>RTCIceCandidateComplete</a></code> dictionary was added as the
     last candidate to the <code><a>RTCIceTransport</a></code> and all appropriate candidate
     pairs have been tested and at least one functioning candidate pair has been found.
      </p></dd>
      <dt>disconnected</dt>
      <dd><p>
     The <code><a>RTCIceTransport</a></code> has received at least one local and remote candidate,
     and a local and remote <code><a>RTCIceCandidateComplete</a></code> dictionary was not added as the last
     candidate, but all appropriate candidate pairs thus far have been tested and failed (or consent checks [[!RFC7675]],
     once successful, have now failed).  Other candidate pairs may become available for testing as new candidates
     are trickled, and therefore the "failed" state has not been reached.
     </p></dd>

      <dt>closed</dt>
      <dd><p>The <code><a>RTCIceTransport</a></code> has shut down and is no longer responding to STUN requests.
      </p></dd>
    </dl>

      <div class="note">
<p>Edge Interop Note:  The Microsoft Edge ORTC API implementation does not support the "failed" state, which is included in 
both the WebRTC 1.0 API as well as recent drafts of the ORTC API. 
One implication of this is that <code><a>RTCIceTransport</a></code> objects transition to the "closed" state under the 
conditions that would normally result in a transition to "failed".
</p>
      </div>

<p>The non-normative ICE state transitions are:</p>

<img alt="The non-normative ICE State Transition Diagram" src="images/msortc-corrected.png" style="width:100%" />
</section>

  <section id="rtcicetransportstatechangedevent-interface-definition*">
      <h3>RTCIceTransportStateChangedEvent</h3>

        <p>The <code>icestatechange</code> event of the <code><a>RTCIceTransport</a></code> object uses
        the <code><a>RTCIceTransportStateChangedEvent</a></code> interface.</p>

        <p>Firing an
        <code><a>RTCIceTransportStateChangedEvent</a></code> event named
        <var>e</var> with an <code><a>RTCIceTransportState</a></code>
        <var>state</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCIceTransportStateChangedEvent</code> interface with the
        <var>state</var> attribute set to the new <code><a>RTCIceTransportState</a></code>, 
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="RTCIceTransportStateChangedEventInit" title=
        "[Constructor(DOMString type, RTCIceTransportStateChangedEventInit eventInitDict)] interface RTCIceTransportStateChangedEvent : Event">

          <dt>readonly attribute RTCIceTransportState state</dt>

          <dd>
            <p>The <var>state</var> attribute is the new
            <code><a>RTCIceTransportState</a></code>  
            that caused the event.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary RTCIceTransportStateChangedEventInit : EventInit">
          <dt>RTCIceTransportState? state</dt>
          <dd>
            <p>The <var>state</var> attribute is the new
            <code><a>RTCIceTransportState</a></code>
            that caused the event.
          </p>
          </dd>
        </dl>
      </section>

  <section id="rtcicecandidatepair*">
  <h3><dfn>RTCIceCandidatePair</dfn> Dictionary</h3>

   <p>
    The <code>RTCIceCandidatePair</code> contains the currently selected ICE candidate pair.
   </p>

    <dl class="idl" title="dictionary RTCIceCandidatePair">
      <dt>RTCIceCandidate local</dt>
      <dd><p>The local ICE candidate.</p></dd>
      <dt>RTCIceCandidate remote</dt>
      <dd><p>The remote ICE candidate.</p></dd>
    </dl>

  </section>
</section>

<section id="rtcdtlstransport*">
<h2><dfn>RTCDtlsTransport</dfn> Interface</h2>

    <p>
The <code>RTCDtlsTransport</code> Interface includes information relating to Datagram Transport Layer Security (DTLS) transport. 

    </p>

  <section id="rtcdtlstransport-overview*">
    <h3>Overview</h3>

    <p>Microsoft Edge does not support the <code>getRemoteCertificates()</code> method, or a <var>state</var> value of "failed".
    Since Microsoft Edge requires support for RTP/RTCP mux with DTLS, an <code><a>RTCDtlsTransport</a></code> object can only be
    constructed from an RTP <code><a>RTCIceTransport</a></code> object. 
    </p>

  </section>

  <section id="rtcdtlstransport-operation*">
    <h3>Operation</h3>

    <p>A <code><a>RTCDtlsTransport</a></code> instance is constructed using an <code><a>RTCIceTransport</a></code> object.
    <p>A newly constructed <code><a>RTCDtlsTransport</a></code>
    <em class="rfc2119" title="MUST">MUST</em> listen and respond to incoming DTLS packets before <code>start()</code> is called.
    However, to complete the negotiation it is necessary to verify the remote fingerprint,
    which is dependent on <var>remoteParameters</var>, passed to <code>start()</code>.
    After the DTLS handshake exchange completes (but before the remote fingerprint is verified) 
    incoming media packets may be received.  A modest buffer <em class="rfc2119" title="MUST">MUST</em> be provided to avoid loss of
    media prior to remote fingerprint validation (which can begin after <code>start()</code> is called). 
   </p>
    <p>If an attempt is made to construct a <code><a>RTCDtlsTransport</a></code> instance from an <code><a>RTCIceTransport</a></code>  in the "closed" state,
    an <code>InvalidStateError</code> exception is thrown. 
    Since the Datagram Transport Layer Security (DTLS) negotiation occurs between transport endpoints determined via ICE, implementations of this specification
    <em class="rfc2119" title="MUST">MUST</em>  support multiplexing of STUN, TURN, DTLS and RTP and RTCP. 
    This multiplexing, originally described in [[!RFC5764]] Section 5.1.2, is being revised in [[RFC7983]]. 
    </p>
  </section>

  <section id="rtcdtlstransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCIceTransport transport)] interface RTCDtlsTransport : RTCStatsProvider">
      <dt>readonly attribute RTCIceTransport transport</dt>
      <dd><p>The associated <code><a>RTCIceTransport</a></code> instance.
      </p></dd>

      <dt>readonly attribute RTCDtlsTransportState state</dt>
      <dd><p>The current state of the DTLS transport.</p></dd>

      <dt>RTCDtlsParameters getLocalParameters()</dt>
      <dd><p>Obtain the DTLS parameters of the local <code><a>RTCDtlsTransport</a></code>.
      </p></dd>

      <dt>RTCDtlsParameters? getRemoteParameters()</dt>
      <dd><p>Obtain the current DTLS parameters of the remote <code><a>RTCDtlsTransport</a></code>.
      </p></dd>

      <dt>void start(RTCDtlsParameters remoteParameters)</dt>
      <dd><p>Start DTLS transport negotiation with the parameters of the remote DTLS transport, including verification
      of the remote fingerprint, 
      then once the DTLS transport session is established, negotiate a <dfn>DTLS-SRTP</dfn> [[!RFC5764]] session to
      establish keys so as protect media using SRTP [[!RFC3711]].  
      Since symmetric RTP [[!RFC4961]] is utilized, the <a>DTLS-SRTP</a> session is bi-directional. 
      </p><p>If <var>remoteParameters</var> is invalid, throw
      an <code>InvalidParameters</code> exception.  If <code>start()</code> is called 
      after a previous <code>start()</code> call, or if <var>state</var> is "closed", 
      throw an <code>InvalidStateError</code> exception. 
      Only a single DTLS transport can be multiplexed over an ICE transport.  
      Therefore if a <code><a>RTCDtlsTransport</a></code> object <var>dtlsTransportB</var> is constructed with an <code><a>RTCIceTransport</a></code>
      object <var>iceTransport</var> previously used to construct another <code><a>RTCDtlsTransport</a></code> object
      <var>dtlsTransportA</var>, then if <code>dtlsTransportB.start()</code> is called prior to having called <code>dtlsTransportA.stop()</code>,
      then throw an <code>InvalidStateError</code> exception. 
      </p> 
      </dd>

      <dt>void stop()</dt>
      <dd><p>Stops and closes the DTLS transport object. 
      Calling <code>stop()</code> when <var>state</var> is "closed" has no effect.
      </p>
      </dd>

      <dt>attribute EventHandler? ondtlsstatechange</dt>
      <dd><p>This event handler, of event handler type <code><a>dtlsstatechange</a></code>,
      uses the <code><a>RTCDtlsTransportStateChangedEvent</a></code> interface.
      It <em class="rfc2119" title="MUST">MUST</em> be supported by
      all objects implementing the <code><a>RTCDtlsTransport</a></code> interface.
      It is called any time the <code>RTCDtlsTransportState</code> changes.
      </p>
      </dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>,
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the <code><a>RTCDtlsTransport</a></code> interface.
      This event <em class="rfc2119" title="MUST">MUST</em> be fired on reception of a DTLS alert.
      </p>
      </dd>
    </dl>
  </section>

  <section id="rtcdtlsparameters*">
   <h3><dfn>RTCDtlsParameters</dfn> Dictionary</h3>

   <p>
     The <code>RTCDtlsParameters</code> object includes information relating to DTLS configuration.
   </p>

    <dl class="idl" title="dictionary RTCDtlsParameters">
      <dt>RTCDtlsRole role="auto"</dt>
      <dd><p>The DTLS role, with a default of auto.</p></dd>
      <dt>sequence&lt;RTCDtlsFingerprint> fingerprints</dt>
      <dd><p>Sequence of fingerprints.</p></dd>
    </dl>
  </section>

  <section id="rtcdtlsfingerprint*">
  <h3><dfn>RTCDtlsFingerprint</dfn> Dictionary</h3>

   <p>
     The <code>RTCDtlsFingerprint</code> object includes the hash function algorithm and certificate fingerprint as described in [[!RFC4572]].
   </p>

    <dl class="idl" title="dictionary RTCDtlsFingerprint">
      <dt>DOMString algorithm</dt>
      <dd><p>One of the the hash function algorithms defined in the 'Hash function Textual Names' registry, initially specified in [[!RFC4572]] Section 8.</p></dd>
      <dt>DOMString value</dt>
      <dd><p>The value of the certificate fingerprint in lowercase hex string as expressed utilizing the syntax of 'fingerprint' in [[!RFC4572]] Section 5.</p></dd>
    </dl>
 </section>

  <section id="rtcdtlsrole*">
    <h3><dfn>RTCDtlsRole</dfn> Enum</h3>
    <p><code>RTCDtlsRole</code> indicates the role of the DTLS transport.
    </p>
    <dl class="idl" title="enum RTCDtlsRole">
      <dt>auto</dt>
      <dd><p><code><a>RTCDtlsRole</a></code> is determined based on the resolved ICE role: the
      "controlled" role acts as the DTLS client and
      the "controlling" role acts as the DTLS server.  Since <code><a>RTCDtlsRole</a></code>
      is initialized to "auto" on construction of an <code><a>RTCDtlsTransport</a></code> object,
      <code>getLocalParameters().role</code> will always return "auto".
      </p></dd>

      <dt>client</dt>
      <dd><p>The DTLS client role.</p></dd>

      <dt>server</dt>
      <dd><p>The DTLS server role.</p></dd>
    </dl>
  </section>

    <section id="rtcdtlsinfo">
       <h3>DTLS role determination</h3>
      <p>To diagnose DTLS role issues, an application may wish to determine
      the desired and actual DTLS role of an <code><a>RTCDtlsTransport</a></code>.
      In Edge ORTC, a <code><a>RTCDtlsTransport</a></code>
      object assumes a DTLS role of <code>auto</code> upon construction.
      This implies that the DTLS role is determined by the ICE role.  Since
      <code>getLocalParameters().role</code> always returns the role assigned
      to an <code><a>RTCDtlsTransport</a></code> object upon construction
      (<code>auto</code> for Edge), the <code>getLocalParameters</code>
      method cannot be used to determine the desired or actual role of an
      <code><a>RTCDtlsTransport</a></code>.</p>
      <p>An application can determine the
      desired role of an <code><a>RTCDtlsTransport</a></code> from the value of
      <code><var>remoteParameters</var>.role</code> passed to
      <code><a>RTCDtlsTransport</a>.start(<var>remoteParameters</var>)</code>.
      If <code><var>remoteParameters</var>.role</code> is <code>server</code>
      then the desired role of the <code><a>RTCDtlsTransport</a></code>
      is <code>client</code>. If <code><var>remoteParameters</var>.role</code>
      is <code>client</code> then the desired role of the
      <code><a>RTCDtlsTransport</a></code> is <code>server</code>.</p>
      <p>The <code>RTCDtlsTransport.transport.onicestatechange</code> EventHandler
      can be used to determine whether an <code><a>RTCDtlsTransport</a></code>
      transitions to the desired role. When
      <code><a>RTCDtlsTransport</a>.transport.state</code> transitions to
      <code>connected</code>, if <code><a>RTCDtlsTransport</a>.transport.role</code>
      is <code>controlled</code> then the role of the
      <code><a>RTCDtlsTransport</a></code> is <code>client</code>.
      If <code><a>RTCDtlsTransport</a>.transport.role</code>
      is <code>controlling</code> then the role of the
      <code><a>RTCDtlsTransport</a></code> is <code>server</code>.</p>
    </section>

  <section id="rtcdtlstransportstate*">
    <h3><dfn>RTCDtlsTransportState</dfn> Enum</h3>
    <p><code>RTCDtlsTransportState</code> indicates the state of the DTLS transport.</p>
    <dl class="idl" title="enum RTCDtlsTransportState">
      <dt>new</dt>
      <dd><p>The <code><a>RTCDtlsTransport</a></code> object has been created and has not started negotiating yet.</p></dd>

      <dt>connecting</dt>
      <dd><p>DTLS is in the process of negotiating a secure connection.  Once a secure connection is negotiated and
      <a>DTLS-SRTP</a> has derived keys (but prior to verification of the remote fingerprint, enabled by calling
      <code>start()</code>), incoming media can flow through.
      </p></dd>

      <dt>connected</dt>
      <dd><p>DTLS has completed negotiation of a secure connection (including <a>DTLS-SRTP</a> and remote fingerprint verification).
      Outgoing media can now flow through.
      </p></dd>

      <dt>closed</dt>
      <dd><p>The DTLS connection has been closed intentionally via a call to <code>stop()</code>, or as the result of
      an error.  
      Calling <code>transport.stop()</code> will also result in a transition to the "closed" state.  
      </p></dd>
    </dl>

      <div class="note">
<p>Edge Interop Note:  The Microsoft Edge ORTC API implementation does not support the "failed" state, which is proposed for inclusion in
the WebRTC 1.0 API as well as the ORTC API.
One implication of this is that <code><a>RTCDtlsTransport</a></code> objects transition to the "closed" state under the
conditions that would normally result in a transition to "failed".
</p>
      </div>


  </section>

  <section id="rtcdtlstransportstatechangedevent-interface-definition*">
      <h3>RTCDtlsTransportStateChangedEvent</h3>

        <p>The <dfn>dtlsstatechange</dfn> event of the <code><a>RTCDtlsTransport</a></code> object uses
        the <code><a>RTCDtlsTransportStateChangedEvent</a></code> interface.</p>

        <p>Firing an
        <code><a>RTCDtlsTransportStateChangedEvent</a></code> event named
        <var>e</var> with an <code><a>RTCDtlsTransportState</a></code>
        <var>state</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code><a>RTCDtlsTransportStateChangedEvent</a></code> interface with the
        <var>state</var> attribute set to the new <code><a>RTCDtlsTransportState</a></code>,
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="RTCDtlsTransportStateChangedEventInit" title=
        "[Constructor(DOMString type, RTCDtlsTransportStateChangedEventInit eventInitDict)] interface RTCDtlsTransportStateChangedEvent : Event">
          <dt>readonly attribute RTCDtlsTransportState state</dt>
          <dd>
            <p>The <var>state</var> attribute is the new
            <code><a>RTCDtlsTransportState</a></code>
            that caused the event.
          </p>
          </dd>
        </dl>

        <dl class="idl" title="dictionary RTCDtlsTransportStateChangedEventInit : EventInit">
          <dt>RTCDtlsTransportState? state</dt>
          <dd>
            <p>The <var>state</var> attribute is the new
            <code><a>RTCDtlsTransportState</a></code>
            that caused the event.
          </p>
          </dd>
        </dl>
   </section>
  <section id="rtcicetransport-example1*">
    <h3>Examples</h3>

   <pre xml:space="preserve" class='example highlight'>
// This is an example of  how to offer ICE and DTLS parameters and 
// ICE candidates and get back ICE and DTLS parameters and ICE candidates,
// and start both ICE and DTLS, when RTP and RTCP are multiplexed. 
// Assume that we have a way to signal (mySignaller). 
// Include some helper functions
import "helper.js";
function initiate(mySignaller) {
  // Prepare the ICE gatherer
  var gatherOptions = new RTCIceGatherOptions();
  gatherOptions.gatherPolicy = RTCIceGatherPolicy.all; 
  gatherOptions.iceservers = [ { urls: "stun:stun1.example.net" } , 
    { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} ]; 
  var iceGatherer = new RTCIceGatherer(gatherOptions); 
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  }; 
  // Create ICE and DTLS transports
  var ice = new RTCIceTransport();
  var dtls = new RTCDtlsTransport(ice);
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(candidate){
   ice.addRemoteCandidate(candidate);
  }
  // ... create RtpSender/RtpReceiver objects as illustrated in Section 7.5 Example 9.

  mySignaller.mySendInitiate({
    "ice": iceGatherer.getLocalParameters(),
    "dtls": dtls.getLocalParameters(),
    // ... include RTP info from other example
  }, function(remote) {
    // Start the ICE transport
    ice.start(iceGatherer, remote.ice, RTCIceRole.controlling);
    dtls.start(remote.dtls);
    // ... configure RtpSender/RtpReceiver objects as illustrated in Section 7.5 Example 9.
  });
}
    </pre>
   <pre xml:space="preserve" class='example highlight'>
// This is an example of how to answer with ICE and DTLS
// and DTLS parameters and ICE candidates and start both ICE and DTLS,
// assuming that RTP and RTCP are multiplexed.
// Include some helper functions
import "helper.js";
// Assume that remote info is signalled to us. 
function accept(mySignaller, remote) {
  var gatherOptions = new RTCIceGatherOptions();
  gatherOptions.gatherPolicy = RTCIceGatherPolicy.all;
  gatherOptions.iceservers = [ { urls: "stun:stun1.example.net" } , 
    { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} ] ;
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };
  // Create ICE and DTLS transports
  var ice = new RTCIceTransport();
  var dtls = new RTCDtlsTransport(ice);
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(candidate){
    ice.addRemoteCandidate(candidate);
  }
  // ... create RtpSender/RtpReceiver objects as illustrated in Section 7.5 Example 9.

  mySignaller.mySendAccept({
    "ice": iceGatherer.getLocalParameters(),
    "dtls": dtls.getLocalParameters()
    // ... marshall RtpSender/RtpReceiver capabilities as illustrated in Section 7.5 Example 9.
  });
  // Start the ICE transport with an implicit gather policy of "all"
  ice.start(iceGatherer, remote.ice, RTCIceRole.controlled);
  // Start the DTLS transport
  dtls.start(remote.dtls);
  // ... configure RtpSender/RtpReceiver objects as illustrated in Section 7.5 Example 9. 
}
</pre>
</section>
</section>

<section id="rtcsrtpsdestransport*">
<h2><dfn>RTCSrtpSdesTransport</dfn> Interface</h2>
<p>The <code>RTCSrtpSdesTransport</code> includes information relating to SRTP/SDES transport [[RFC4568]].
Details relating to configuration of Microsoft's implementation of SRTP/SDES are described in [[MS-SDPEXT]].</p>
      <div class="note">
<p>SRTP/SDES support is forbidden by the IETF RTCWEB security specifications. 
To conform to this requirement, support for SRTP/SDES will be removed from Microsoft Edge in the future.
Therefore, applications also need to support DTLS/SRTP so they will continue to function once SRTP/SDES support is removed.</p>
      </div>
    </p>

  <section id="rtcsrtpsdestransport-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCSrtpSdesTransport</a></code> instance is associated to an <code>RTCRtpSender</code> or an <code><a>RTCRtpReceiver</a></code>.</p>

  </section>

  <section id="rtcsrtpsdestransport-operation*">
    <h3>Operation</h3>

    <p>An <code><a>RTCSrtpSdesTransport</a></code> instance is constructed from an <code>RTCIceTransport</code>, as well as the encryption parameters (obtained from the local peer)
    and the decryption parameters (obtained from the remote peer).
    Both multiplexed and non-multiplexed RTP/RTCP are supported with <code><a>RTCSrtpSdesTransport</a></code> objects.
    If RTP and RTCP are not multiplexed,
    the RTP <code>RTCIceTransport</code> instance <var>transport</var> passed in the constructor is sufficient; if there is an
    "associated" RTCP transport <var>rtcpTransport</var>,
    it is provided implicitly.
    Since an <code>RTCSrtpSdesTransport</code> is ready to function as soon as it is created,
    there is no need for <code>start()</code> and <code>stop()</code> methods.</p>
    <p>If either <var>encryptParameters</var> or <var>decryptParameters</var> contain a sequence of more than
    one <var>keyParams</var> dictionary, then <var>keyParams.mkiValue</var>
    and <var>keyParams.mkiLength</var> MUST be set to a value greater than zero
    for each <var>keyParams</var> dictionary entry or an <code>InvalidParameters</code>
    exception is thrown.</p>
  </section>

  <section id="rtcsrtpsdestransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCIceTransport transport, RTCSrtpSdesParameters encryptParameters, RTCSrtpSdesParameters decryptParameters)] interface RTCSrtpSdesTransport">
      <dt>readonly attribute RTCIceTransport transport</dt>
      <dd><p>The associated <code>RTCIceTransport</code> instance.
      If <code>transport.createAssociatedTransport()</code> has been previously called and the constructed
      RTCP <code><a>RTCIceTransport</a></code> is not in the "closed" state, this indicates the desire to not
      multiplex RTP and RTCP.  
      If <var>transport.component</var> is "RTCP" throw an <code>InvalidParameters</code> exception. 
      </p></dd>

      <dt>static sequence&lt;RTCSrtpSdesParameters> getLocalParameters()</dt>
      <dd><p>Obtain the local SRTP/SDES parameter sets.
      </p></dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>Set this handler to receive error events.</p></dd>
    </dl>
  </section>

  <section id="rtcsrtpsdesparameters*">
  <h3><dfn>RTCSrtpSdesParameters</dfn> Dictionary</h3>

   <p>The <code>RTCSrtpSdesParameters</code> object includes information relating to SRTP/SDES configuration.
   </p>

    <dl class="idl" title="dictionary RTCSrtpSdesParameters">
      <dt>unsigned short tag</dt>
      <dd><p>The tag identifying the parameters set, in the syntax defined for 'tag' in [[!RFC4568]] Section 9.1.</p></dd>
      <dt>DOMString cryptoSuite</dt>
      <dd><p>The ciphersuite to be utilized, in the syntax defined for 'srtp-crypto-suite'
      in [[!RFC4568]] Section 9.2</p></dd>
      <dt>sequence&lt;RTCSrtpKeyParam> keyParams</dt>
      <dd><p>The key parameters to be utilized, as described in [[!RFC4568]] Section 6.1.
      Calls to <code>RTCSrtpSdesTransport.getLocalParameters</code> SHOULD return only a single <code>RTCSrtpKeyParam</code>
      dictionary entry.
      </p></dd>
      <dt>sequence&lt;DOMString> sessionParams</dt>
      <dd><p>A sequence of session parameters to be utilized, each in the syntax defined for 'session-param'
      in [[!RFC4568]] Section 9.1</p></dd>
    </dl>
  </section>

  <section id="rtcsrtpkeyparam*">
  <h3><dfn>RTCSrtpKeyParam</dfn> Dictionary</h3>

    <dl class="idl" title="dictionary RTCSrtpKeyParam">
      <dt>DOMString keyMethod</dt>
      <dd><p>The key method to be utilized, in the syntax defined for 'srtp-key-method' in [[!RFC4568]] Section 9.2.</p></dd>
      <dt>DOMString keySalt</dt>
      <dd><p>The key and salt to be utilized, in the syntax defined for 'key-salt' in [[!RFC4568]] Sections 9.2.</p></dd>
      <dt>DOMString lifetime</dt>
      <dd><p>The key lifetime to be utilized, in the syntax defined for 'lifetime' in [[!RFC4568]] Section 9.2.</p></dd>
      <dt>unsigned short mkiValue</dt>
      <dd><p>The master key index to be utilized.  
      </p></dd>
      <dt>unsigned short mkiLength</dt>
      <dd><p>The master key index length in decimal digits, in the syntax defined for 'mki-length' in [[!RFC4568]] Section 9.2.</p></dd>
    </dl>

      <div class="note">
<p>Edge Interop Note:  Limitations of the Microsoft Edge SRTP/SDES implementation are described in [[MS-SDPEXT]] Extion 3.1.5.1. In Microsoft Edge, the value of 'lifetime' is ignored and is set internally to 2^31.  
'mki-value' is defined in [[!RFC4568]] Section 9.2 as a string
containing up to 128 decimal digits.  However, the only supported value of 'mkiLength' is 1, so that Microsoft Edge only supports values of 'mki-value' from 
0 to 255.</p>  
      </div>

  </section>
  <section id="rtcsrtpsdestransport-example*">
    <h3>Examples</h3>
   <pre xml:space="preserve" class='example highlight'>
// This is an example of  how to offer ICE and SRTP/SDES parameters and 
// ICE candidates and get back ICE and SRTP/SDES parameters and ICE candidates,
// and start both ICE and SRTP/SDES, when RTP and RTCP are multiplexed. 
// Assume that we have a way to signal (mySignaller). 
// Include some helper functions
import "helper.js";
function initiate(mySignaller) {
  // Prepare the ICE gatherer
  var gatherOptions = new RTCIceGatherOptions();
  gatherOptions.gatherPolicy = RTCIceGatherPolicy.all; 
  gatherOptions.iceservers = [ { urls: "stun:stun1.example.net" } , 
    { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} ]; 
  var iceGatherer = new RTCIceGatherer(gatherOptions); 
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  }; 
  // Create ICE transport
  var ice = new RTCIceTransport();
  // Get SRTP/SDES encryption parameters
  var encryptParams = RTCSrtpSdesTransport.getLocalParameters(); 
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(candidate){
   ice.addRemoteCandidate(candidate);
  }
  // ... create RtpSender/RtpReceiver objects as illustrated in Section 7.5 Example 9

  mySignaller.mySendInitiate({
    "ice": iceGatherer.getLocalParameters(),
    "srtpsdes": encryptParams, 
    // ... include RTP info from other example
  }, function(remote) {
    // Start the ICE transport
    ice.start(iceGatherer, remote.ice, RTCIceRole.controlling);
    // Construct the SRTP/SDES transport (which auto-starts)
    var srtpsdes = new RTCSrtpSdesTransport(ice, encryptParams, remote.srtpsdes);  
    // ... configure RtpSender/RtpReceiver objects as illustrated in Section 7.5 Example 9
  });
}
    </pre>
   <pre xml:space="preserve" class='example highlight'>
// This is an example of how to answer with ICE and SRTP/SDES
// parameters and ICE candidates and start both ICE and SRTP/SDES, 
// assuming that RTP and RTCP are multiplexed.
// Include some helper functions
import "helper.js";
// Assume that remote info is signalled to us. 
function accept(mySignaller, remote) {
  var gatherOptions = new RTCIceGatherOptions();
  gatherOptions.gatherPolicy = RTCIceGatherPolicy.all;
  gatherOptions.iceservers = [ { urls: "stun:stun1.example.net" } , 
    { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} ] ;
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };
  // Create ICE transport
  var ice = new RTCIceTransport();
  // Get SRTP/SDES encryption parameters
  var encryptParams = RTCSrtpSdesTransport.getLocalParameters();
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(candidate){
    ice.addRemoteCandidate(candidate);
  }
  // ... create RtpSender/RtpReceiver objects as illustrated in Section 7.5 Example 9. 

  mySignaller.mySendAccept({
    "ice": iceGatherer.getLocalParameters(),
    "srtpsdes": encryptParams, 
    // ... marshall RtpSender/RtpReceiver capabilities as illustrated in Section 7.5 Example 9. 
  });
  // Start the ICE transport with an implicit gather policy of "all"
  ice.start(iceGatherer, remote.ice, RTCIceRole.controlled);
    // Construct the SRTP/SDES transport (which auto-starts)
    var srtpsdes = new RTCSrtpSdesTransport(ice, encryptParams, remote.srtpsdes);
  // ... configure RtpSender/RtpReceiver objects as illustrated in Section 7.5 Example 9. 
}
    </pre>
  </section>
</section>

  <section id="rtcrtpsender*">
  <h2><dfn>RTCRtpSender</dfn> Interface</h2>

    <p>
      The <code>RTCRtpSender</code> includes information relating to the RTP sender.
    </p>

  <section id="rtcrtpsender-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCRtpSender</a></code> instance is associated to a sending <a>MediaStreamTrack</a> 
    and provides RTC related methods to it.</p>
  </section>

  <section id="rtcrtpsender-operation*">
    <h3>Operation</h3>

    <p>A <code><a>RTCRtpSender</a></code> instance is constructed from an <a>MediaStreamTrack</a> object and 
    associated to an <code><a>RTCDtlsTransport</a></code> or an <code><a>RTCSrtpSdesTransport</a></code>. 
    If an attempt is made to construct an <code><a>RTCRtpSender</a></code> object with <var>transport.state</var> or <var>rtcpTransport.state</var> "closed",
    throw an <code>InvalidStateError</code> exception.
    </p>

    <div class="note">
    <p>Edge Interop Note: The Microsoft Edge ORTC API implementation requires use of RTP/RTCP multiplexing with <code><a>RTCDtlsTransport</a></code> objects.
    Therefore only a single <code><a>RTCDtlsTransport</a></code> instance can be associated to an <code><a>RTCRtpSender</a></code> instance.
    RTP/RTCP non-mux is supported for <code><a>RTCSrtpSdesTransport</a></code> objects.  Only a single <code><a>RTCSrtpSdesTransport</a></code> object
    is required to handle both RTP and RTCP.
    </p>
    </div>

  </section>

  <section id="rtcrtpsender-interface-definition*">
    <h3>Interface Definition</h3>

       <dl class="idl" title="typedef (RTCDtlsTransport or RTCSrtpSdesTransport) RTCTransport">
       </dl>

    <dl class="idl" title="[Constructor(MediaStreamTrack track, RTCTransport transport)] interface RTCRtpSender : RTCStatsProvider">
      <dt>readonly attribute MediaStreamTrack                    track</dt>
      <dd>
        <p>The associated <code><a>MediaStreamTrack</a></code> instance.</p>
      </dd>
      
      <dt>readonly attribute RTCTransport                    transport</dt>
      <dd>
        <p>The associated transport (either an <code><a>RTCDtlsTransport</a></code> or an <code><a>RTCSrtpSdesTransport</a></code>) instance.</p>
      </dd>

      <dt>void setTransport(RTCTransport transport)</dt>
              <dd><p><code>setTransport()</code>
              attempts to replace the transport (either <code><a>RTCDtlsTransport</a></code> or
              <code><a>RTCSrtpSdesTransport</a></code>) with the transport provided.  Only RTP/RTCP multiplexing
              is supported if <var>transport</var> is an <code><a>RTCDtlsTransport</a></code>.</p>
              <p>When the <code>setTransport()</code> method is invoked, the user
              agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>sender</var> be the <code><a>RTCRtpSender</a></code> object
                  on which <code>setTransport()</code> is invoked.</p>
                </li>
                <li>
                  <p>If <code><var>sender</var>.stop()</code> has been called, throw an
                  <code>InvalidStateError</code> exception.</p>
                </li>
                <li>
                  <p>Let <var>withTransport</var> be the argument to this method.</p>
                </li>
                <li>
                  <p>If <code>setTransport()</code> is called with no arguments,
                  or if <var>withTransport</var> is unset, throw an
                  <code>InvalidParameters</code> exception.</p>
                </li>
                <li>
                  <p>If <code><var>withTransport</var>.transport.component</code> is
                  <code>rtcp</code>, throw an <code>InvalidParameters</code>
                  exception.</p>
                <li>
                  <p>If <code><var>withTransport</var></code> is set and
                  <code><var>withTransport</var>.state</code> is
                  <code>closed</code>, throw an <code>InvalidStateError</code>
                  exception.</p>
                </li>
                <li>
                  <p>Replace <code>transport</code> with <var>withTransport</var>
                  and seamlessly send over the new transport(s).</p>
                </li>
              </ol>
      </dd>

      <dt>void setTrack(MediaStreamTrack track)</dt>
      <dd><p>Set the <var>track</var>.  If <var>track.kind</var> is changed, or if the new <var>track</var> has different peerIdentity constraints, 
      throw an <code>InvalidParameter</code> Exception.
      </p></dd>

      <dt>static RTCRtpCapabilities getCapabilities(optional DOMString kind)</dt>
      <dd><p>Obtain the sender capabilities, based on <var>kind</var>.  If <var>kind</var> is
      omitted or is set to "", then all capabilities are returned.
      Microsoft Edge does not support codecs such as retransmission [[!RFC4588]], redundancy [[RFC2198]] or
      Forward Error Correction which do not have an associated value of <var>kind</var> (and therefore would
      always be returned). 
      </p></dd>
      <dt>void send(RTCRtpParameters parameters)</dt>
      <dd><p>Media to be sent is controlled by parameters.
      If <code>send()</code> is called with invalid <var>parameters</var>,
      throw an <code>InvalidParameters</code> exception.
      If <var>transport</var> is an <code><a>RTCDtlsTransport</a></code> and <code>send(parameters)</code> 
      is called with <var>parameters.rtcp.mux</var>
      set to <code>false</code>, throw an <code>InvalidParameters</code> exception.
      The <code>send()</code> method does not update
      <var>parameters</var> based on what is currently being sent, so that the value of <var>parameters</var> remains that
      last passed to the <code>send()</code> method.
      The <code>RTCRtpSender</code> object starts sending when <code>send()</code> 
      is called for the first time, and changes the sending <code>parameters</code> when <code>send()</code> is called again. 
      The <code>RTCRtpSender</code> object stops sending when <code>stop()</code> is called.
      </p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops sending the track on the wire, and sends an RTCP BYE.  
      Stop is final as in <code>MediaStreamTrack.stop()</code></p></dd>

      <dt>void msSmartCrop(boolean on = false)</dt>
      <dd><p>Indicates whether the sender will send crop information.
      By default, cropping is turned off.</p></dd>
	       
      <dt>attribute EventHandler? onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>,
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the <code><a>RTCRtpSender</a></code> interface.
      This event <em class="rfc2119" title="MUST">MUST</em> be fired if an issue is found 
      with the <code><a>RTCRtpParameters</a></code> object passed to
      <code>send()</code>, that is not immediately detected.
      </p></dd>

      <dt>attribute EventHandler? onmsquality</dt>
      <dd><p>This event handler, of event handler type <code>msquality</code>,
      MUST be fired when an event affecting session quality occurs.
      </p></dd>
    </dl>
  </section>
  <section id="msquality-interface-definition*">
      <h3>msquality</h3>

        <p>The <code>msquality</code> event uses the
        <code><a>MSQualityEvent</a></code> interface.</p>

        <p>Firing a <code>msquality</code> event named <var>e</var>
        with <code>messages</code> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code><a>MSQualityEvent</a></code> interface with the
        <var>messages</var> attribute
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="MSQualityEventInit" title=
        "[Constructor(DOMString type, MSQualityEventInit eventInitDict)] interface MSQualityEvent : Event">
          <dt>readonly attribute sequence&lt;MSQualityMessage> messages</dt>
          <dd>The <var>messages</var> attribute contains the quality events that have been fired.</dd>
        </dl>
	  
        <dl class="idl" title=
        "dictionary MSQualityEventInit : EventInit">
          <dt>sequence&lt;MSQualityMessage> messages</dt>
          <dd>The <var>messages</var> attribute contains the quality events that have been fired.</dd>
        </dl>
   </section>		
   <section id="msqualitymessage-dictionary*">
      <h3><dfn>MSQualityMessage</dfn> Dictionary</h3>
      <p>
	      The <code>MSQualityMessages</code> dictionary contains the name and value of a quality event,
	      contained in the table below:
      </p>
	    <table class="simple">
            <thead>
              <tr>
                <th>Name</th>
                <th>Description</th>
                <th>Sender/Receiver</th>
		<th>Quality Level</th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-nsq">
                <td><dfn>NetworkSendQuality</dfn></td>
                <td>
                  Network quality condition in terms of jitter or packet loss.</br>
                  "Poor" indicates noticeable impact on the quality of audio being sent</br>
                  "Bad" means severe impact</br>
                  "Catastrophic" means network quality does not allow real-time communication.
                </td>
                <td>Sender</td>
		<td>"Good"/"Poor"/"Bad"/"Catastrophic"</td>
              </tr>
              <tr id="def-nrq">
                <td><dfn>NetworkReceiveQuality</dfn></td>
                <td>
                  Network quality condition in terms of jitter or packet loss.</br>
                  "Poor" indicates noticeable impact on the quality of audio being received</br>
                  "Bad" means severe impact</br>
                  "Catastrophic" means network quality does not allow real-time communication.
                </td>
		<td>Receiver</td>
		<td>"Good"/"Poor"/"Bad"/"Catastrophic"</td>
              </tr>
	      <tr id="def-nd">
                <td><dfn>NetworkLatency</dfn></td>
                <td>Network latency condition. "Bad" is severe and is preventing interactive communication.</td>
                <td>Sender</td>
		<td>"Good"/"Bad"</td>
              </tr>
              <tr id="def-nbl">
                <td><dfn>NetworkBandwidth</dfn></td>
                <td>The available bandwidth condition.  "Bad" is insufficient for an acceptable audio or voice experience.</td>
                <td>Sender</td>
		<td>"Good"/"Bad"</td>
              </tr>
	      <tr id="def-nr">
                <td><dfn>NetworkReconnect</dfn></td>
                <td>"Network_Lost" means network connectivity has failed. "App_Attempt_Restart" means that the application
		may attempt an ICE restart</td>
                <td>Sender/Receiver</td>
	        <td>"Network_Lost"/"App_Attempt_Restart"</td>
              </tr>
	      <tr id="def-dri">
                <td><dfn>DeviceRenderGlitches</dfn></td>
                <td>"Yes" means that there are severe issues in the rendering of audio which is causing distortion.
	        These issues can be caused by driver problems, deferred procedure call (DPC) storms
	        (drivers), and high CPU usage.</td>
                <td>Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
              <tr id="def-dls">
                <td><dfn>DeviceSNR</dfn></td>
                <td>"Bad" means capture quality is very poor, either due to noise or because the user is too
	        far from the microphone. This will cause distortion.</td>
                <td>Sender</td>
		<td>"Good"/"Bad"</td>
              </tr>
              <tr id="def-dlsl">
                <td><dfn>DeviceSpeechLevel</dfn></td>
                <td>"Bad" means the user‘s speech level is too low and the system cannot increase it any further.
		This can either cause distortion or it can be perceived as one-way audio.</td>
                <td>Sender</td>
		<td>"Good"/"Bad"</td>
              </tr>
	      <tr id="def-dc">
                <td><dfn>DeviceClipping</dfn></td>
                <td>"Bad" means near-end speech clips the microphone, the far-end hears distortion due to clipping.</td>
                <td>Sender</td>
		<td>"Good"/"Bad"</td>
              </tr>
	      <tr id="def-de">
                <td><dfn>DeviceEcho</dfn></td>
                <td>"Bad" means the device or setup is causing echo beyond the ability of the system to compensate.</td>
                <td>Sender</td>
		<td>"Good"/"Bad"</td>
              </tr>
	      <tr id="def-dhdaec">
                <td><dfn>DeviceHalfDuplexAec</dfn></td>
                <td>"Yes" means that in order to prevent echo, the system has entered the half duplex voice switching state.
	        Interactive communication will be impacted.</td>
                <td>Sender/Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
	      <tr id="def-dmep">
                <td><dfn>DeviceMultipleEndpoints</dfn></td>
                <td>"Yes" means multiple audio endpoints in the same session have been detected and the system has
	        compensated by reducing render volume.</td>
                <td>Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
	      <tr id="def-dh">
                <td><dfn>DeviceHowling</dfn></td>
                <td>"Yes" means an audio feedback loop has been detected, caused by multiple endpoints sharing an audio path.</td>
                <td>Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
	      <tr id="def-drzv">
                <td><dfn>DeviceRenderZeroVolume</dfn></td>
                <td>"Yes" means the render device was set to zero volume at the operating system level.</td>
                <td>Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
	      <tr id="def-vbr">
                <td><dfn>ScreenSharingRendered</dfn></td>
                <td>"Yes" means video-based screen sharing is decoding and decompressed frames are being pushed to the renderer.</td>
                <td>Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
	      <tr id="def-neiu">
                <td><dfn>NetworkEthernetInterfaceUsed</dfn></td>
                <td>"Yes" means the Ethernet interface was used for the call.</td>
                <td>Sender/Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
	      <tr id="def-nwliu">
                <td><dfn>NetworkWlanInterfaceUsed</dfn></td>
                <td>"Yes" means the WLAN interface was used for the call.</td>
                <td>Sender/Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
	      <tr id="def-nwwiu">
                <td><dfn>NetworkWwanInterfaceUsed</dfn></td>
                <td>"Yes" means the WWAN interface was used for the call.</td>
                <td>Sender/Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
	      <tr id="def-nr">
                <td><dfn>NetworkRoaming</dfn></td>
                <td>"Network_Issue_Detected" means that a (potentially transient) network connectivity loss
	        has been detected. "Network_Recovery_in_Progress" indicates that the browser is attempting to
	        recover from the connectivity loss.  "Network_Recovery_Successful" indicates that the attempt to
	        recover has succeeded.</td>
                <td>Sender/Receiver</td>
		<td>"Network_Issue_Detected"/"Network_Recovery_in_Progress"/"Network_Recovery_Successful"</td>
              </tr>
	      <tr id="def-rnr">
                <td><dfn>RelayUnReachable</dfn></td>
                <td>"Yes" means unable to reach the relay servers currently deployed.
	        This could be due to blocking by a firewall/proxy.</td>
                <td>Sender/Receiver</td>
		<td>"Yes"/"No"</td>
              </tr>
              <tr id="def=ncs">
                <td><dfn>NetworkConnectionStatus</dfn></td>
                <td>
                  "NoNetwork" means the user is not connected to any network.</br>
                  "NoInternetAccess" means the user is connected to a network without Internet access.</br>
                  "InternetAccess" means the user is connected to the Internet.
                </td>
                <td>Sender/Receiver</td>
                <td>"NoNetwork"/"NoInternetAccess"/"InternetAccess"</td>
              </tr>
              <tr id="def=acis">
                <td><dfn>AudioCaptureIsSilent</dfn></td>
                <td>
                  detects OS/HW mute or driver/device issues.</br>
                  "Yes" means level of captured audio samples is zero.</br>
                </td>
                <td>Sender</td>
                <td>"Yes"/"No"</td>
              </tr>
              <tr id="def=ci">
                <td><dfn>CpuInsufficient</dfn></td>
                <td>
                  "Yes" means the CPU load is to high.
                </td>
                <td>Sender/Receiver</td>
                <td>"Yes"/"No"</td>
              </tr>
            </tbody>
          </table>
	   
    <dl title='dictionary MSQualityMessage' class='idl'>
      <dt>DOMString name</dt>
      <dd><p>The name of the quality event.</p></dd>
      <dt>DOMString value</dt>
      <dd><p>The value of the quality event.</p></dd>
    </dl>
  </section>
</section>

<section id="rtcrtpreceiver*">
<h2><dfn>RTCRtpReceiver</dfn> Interface</h2>

    <p>
      The <code>RTCRtpReceiver</code> includes information relating to the RTP receiver. 
    </p>

  <section id="rtcrtpreceiver-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCRtpReceiver</a></code> instance is associated to a receiving 
    <a>MediaStreamTrack</a> and provides RTC related methods to it.  Microsoft Edge requires <var>kind</var>
    to be set in the constructor so as to allow a newly constructed <code><a>RTCRtpReceiver</a></code> to  be used with an 
    audio or video tag immediately, rather than having to wait until <code>receive()</code> is called for the value of <var>kind</var> to be determined.   
    </p>

      <div class="note">
    <p>Edge Interop Note: The Microsoft Edge ORTC API implementation requires use of RTP/RTCP multiplexing with <code><a>RTCDtlsTransport</a></code> objects.
    Therefore only a single <code><a>RTCDtlsTransport</a></code> instance can be associated to an 
    <code><a>RTCRtpReceiver</a></code> instance.
    RTP/RTCP non-mux is supported for <code><a>RTCSrtpSdesTransport</a></code> objects.  Only a single <code><a>RTCSrtpSdesTransport</a></code> object
    is required to handle both RTP and RTCP.
    </p>
    </div>

  </section>

  <section id="rtcrtpreceiver-operation*">
    <h3>Operation</h3>

    <p>A <code><a>RTCRtpReceiver</a></code> instance is constructed from an <code><a>RTCDtlsTransport</a></code> object
    or an <code><a>RTCSrtpSdesTransport</a></code> object.
    If an attempt is made to construct an <code><a>RTCRtpReceiver</a></code> object with <var>transport.state</var> or <var>rtcpTransport.state</var> "closed",
    throw an <code>InvalidStateError</code> exception.
   </p>
  </section>

  <section id="rtcrtpreceiver-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCTransport transport, DOMString kind)] interface RTCRtpReceiver : RTCStatsProvider">
      <dt>readonly attribute MediaStreamTrack? track</dt>
      <dd>
        <p>The associated <code><a>MediaStreamTrack</a></code> instance.</p>
      </dd>

      <dt>readonly attribute RTCTransport                    transport</dt>
      <dd>
        <p>The associated transport instance (either an <code><a>RTCDtlsTransport</a></code> or a <code><a>RTCSrtpSdesTransport</a></code>).</p>
      </dd>
      <dt>void setTransport(RTCTransport transport)</dt>
              <dd><p><code>setTransport()</code>
              attempts to replace the transport (either <code><a>RTCDtlsTransport</a></code> or
              <code><a>RTCSrtpSdesTransport</a></code>) with the transport provided.  Only RTP/RTCP multiplexing
              is supported if <var>transport</var> is an <code><a>RTCDtlsTransport</a></code>.</p>
              <p>When the <code>setTransport()</code> method is invoked, the user
              agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>receiver</var> be the <code><a>RTCRtpReceiver</a></code> object
                  on which <code>setTransport()</code> is invoked.</p>
                </li>
                <li>
                  <p>If <code><var>receiver</var>.stop()</code> has been called, throw an
                  <code>InvalidStateError</code> exception.</p>
                </li>
                <li>
                  <p>Let <var>withTransport</var> be the argument to this method.</p>
                </li>
                <li>
                  <p>If <code>setTransport()</code> is called with no arguments,
                  or if <var>withTransport</var> is unset, throw an
                  <code>InvalidParameters</code> exception.</p>
                </li>
                <li>
                  <p>If <code><var>withTransport</var>.transport.component</code> is
                  <code>rtcp</code>, throw an <code>InvalidParameters</code>
                  exception.</p>
                <li>
                  <p>If <code><var>withTransport</var></code> is set and
                  <code><var>withTransport</var>.state</code> is
                  <code>closed</code>, throw an <code>InvalidStateError</code>
                  exception.</p>
                </li>
                <li>
                  <p>Replace <code>transport</code> with <var>withTransport</var>
                  and seamlessly receive over the new transport.</p>
                </li>
              </ol>
      </dd>
      <dt>static RTCRtpCapabilities getCapabilities(optional DOMString kind)</dt>
      <dd><p>Obtain the receiver capabilities, based on <var>kind</var>.  If <var>kind</var> is omitted or set to "", then
      all capabilities are returned. 
      Capabilities such as retransmission [[!RFC4588]], redundancy [[RFC2198]], and
      Forward Error Correction that do not have an associated value of <var>kind</var> are always
      included, regardless of the value of <var>kind</var> passed to <code>getCapabilities()</code>.
      To avoid confusion, <code>getCapabilities(kind)</code> should return codecs with a matching intrinsic <var>kind</var> value, 
      as well as codecs with no intrinsic <var>kind</var>
      (such as redundancy [[RFC2198]]).    
      For codecs with no intrinsic <var>kind</var>, <var>RTCRtpCapabilities.RTCRtpCodecCapability[i].kind</var>
      returned by <code>getCapabilities(kind)</code> should be set to the value of <var>kind</var> if <var>kind</var> is
      equal to "audio" or "video". If the <var>kind</var> argument was omitted or set to "", then 
      the value of <var>RTCRtpCapabilities.RTCRtpCodecCapability[i].kind</var> is set to "". 
      </p></dd>
      <dt>sequence&lt;RTCRtpContributingSource> getContributingSources()</dt>
      <dd><p>Retrieve the sequence of contributing sources.</p></dd>
      <dt>void receive(RTCRtpParameters parameters)</dt>
      <dd><p>Media to be received is controlled by <var>parameters</var>.  
      If <code>receive(parameters)</code> is called with invalid <var>parameters</var>,
      throw an <code>InvalidParameters</code> exception.
      If <var>transport</var> is an <code><a>RTCDtlsTransport</a></code> and <code>receive(parameters)</code> is called 
      with <var>parameters.rtcp.mux</var>
      set to <code>false</code>, throw an <code>InvalidParameters</code> exception.
      The <code>receive()</code> method does not update
      <var>parameters</var> based on what is currently being received, so that the value of <var>parameters</var> remains that
      last passed to the <code>receive()</code> method.
      The <code>RTCRtpReceiver</code> object starts receiving when <code>receive()</code>       
      is called for the first time, and changes the receiving <code>parameters</code> when <code>receive()</code> is called again.
      The <code>RTCRtpReceiver</code> object stops receiving when <code>stop()</code> is called.

      After <code>receive()</code> returns, <var>track</var> is set. The value of <var>track.kind</var> is determined
      based on the <var>kind</var> used in the constructor, which must match that of the codecs provided in <var>parameters.codecs</var>.  
      If <var>parameters.codecs</var> are of mixed <var>kind</var>, or are of a single <var>kind</var> which does not match the 
      value used in the constructor, 
      throw an <code>InvalidParameters</code> exception.  For this purpose a <var>kind</var> of "" is not considered mixed. 
     </p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops receiving the track on the wire. Stop is final like <a>MediaStreamTrack</a>.
      </p></dd>

      <dt>void msSmartCrop(boolean on = false)</dt>
      <dd><p>Indicates whether the receiver will utilize crop information if it is provided by the sender.
      By default, cropping is turned off.</p></dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>,
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the <code><a>RTCRtpReceiver</a></code> interface.
      This event <em class="rfc2119" title="MUST">MUST</em> be fired if an issue is found with the <code><a>RTCRtpParameters</a></code> object passed to
      <code>receive()</code>, that is not immediately detected.
    </p></dd>

      <dt>attribute EventHandler? onmsdsh</dt>
      <dd><p>This event handler, of event handler type <code>msdsh</code>,
      MUST be fired when a Dominant Speaker History (DSH) RTCP packet is received, indicating a change in the dominant speaker(s).
      </p></dd>

      <dt>attribute EventHandler? onmsdecodercapacitychange</dt>
      <dd><p>This event handler, of event handler type <code>msdecodercapacitychange</code>,
      MUST be fired when the decoder capacity changes.
      </p></dd>

      <dt>attribute EventHandler? onmsquality</dt>
      <dd><p>This event handler, of event handler type <code>msquality</code>,
      MUST be fired when an event affecting session quality occurs.
      </p></dd>
    </dl>
  </section>

  <section id="rtcrtpcontributingsource*">
  <h3><dfn>RTCRtpContributingSource</dfn> Dictionary</h3>
    <dl title='dictionary RTCRtpContributingSource' class='idl'>
      <dt>DOMHighResTimeStamp timestamp</dt>
      <dd><p>Timestamp indicating when an RTP packet containing the contributing source was last received.
       The time is relative to the UNIX epoch (Jan 1, 1970, UTC).</p></dd>
      <dt>unsigned long csrc</dt>
      <dd><p>The contributing source.</p></dd>
    </dl>
  </section>

  <section id="msdsh-interface-definition*">
      <h3>dsh</h3>

        <p>The <code>msdsh</code> event of the <code><a>RTCRtpReceiver</a></code> object uses
        the <code><a>MSDSHEvent</a></code> interface.</p>

        <p>Firing a <code>msdsh</code> event named <var>e</var>
        with <var>timestamp</var> and <var>sources</var>
        means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code><a>MSDSHEvent</a></code> interface
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="MSDSHEventInit" title=
        "[Constructor(DOMString type, MSDSHEventInit eventInitDict)] interface MSDSHEvent : Event">
          <dt>readonly attribute DOMHighResTimeStamp timestamp</dt>
          <dd><p>Timestamp indicating when an RTP packet containing the contributing source was last received.
          The time is relative to the UNIX epoch (Jan 1, 1970, UTC).</p></dd>
          <dt>readonly attribute sequence&lt;unsigned long> sources</dt>
          <dd>
            <p>The <var>sources</var> attribute contains the sequence of
            new dominant speakers that caused the event.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary MSDSHEventInit : EventInit">
          <dt>DOMHighResTimeStamp timestamp</dt>
          <dd><p>Timestamp indicating when an RTP packet containing the contributing source was last received.
          The time is relative to the UNIX epoch (Jan 1, 1970, UTC).</p></dd>
          <dt>sequence&lt;unsigned long> sources</dt>
          <dd>
            <p>The <var>sources</var> attribute contains the sequence of
            new dominant speakers that caused the event.
          </p>
          </dd>
        </dl>
      </section>

  <section id="msdecodercapacitychange-interface-definition*">
      <h3>msdecodercapacitychange</h3>

        <p>The <code>msdecodercapacitychange</code> event of the <code><a>RTCRtpReceiver</a></code> object uses
        the <code><a>MSDCCEvent</a></code> interface.</p>

        <p>Firing a <code>msdecodercapacitychange</code> event named <var>e</var>
        with <code>maxFr</code> and <code>maxFs</code> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code><a>MSDCCEvent</a></code> interface with the
        <var>maxFr</var> <var>maxFs</var> attributes
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="MSDCCEventInit" title=
        "[Constructor(DOMString type, MSDCCEventInit eventInitDict)] interface MSDCCEvent : Event">
          <dt>readonly attribute unsigned long maxFr</dt>
          <dd>
            <p>The <var>maxFr</var> attribute contains the maximum frame rate
            per second capacity.
          </p>
          </dd>
          <dt>readonly attribute unsigned long maxFs</dt>
          <dd>
            <p>The <var>maxFs</var> attribute contains the maximum macroblock
            per second capacity. 
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary MSDCCEventInit : EventInit">
          <dt>unsigned long maxFr</dt>
          <dd>
            <p>The <var>maxFr</var> attribute contains the maximum frame rate
            per second capacity. 
          </p>
          </dd>
          <dt>unsigned long maxFs</dt>
          <dd>
            <p>The <var>maxFs</var> attribute contains the maximum macroblock
            per second capacity.
          </p>
          </dd>
        </dl>
   </section>


  <section id="rtcrtpreceiver-example*">
    <h3>Examples</h3>

   <pre xml:space="preserve" class='example highlight'>
// Assume we already have a way to signal, a transport
// (RTCDtlsTransport), and audio and video tracks. This is an example
// of  how to offer them  and get back an answer with audio and
// video tracks, and begin sending and receiving them.
// The example assumes that RTP and RTCP are multiplexed. 
function myInitiate(mySignaller, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver(transport, 'audio');
  var videoReceiver = new RTCRtpReceiver(transport, 'video');

// Retrieve the audio and video receiver capabilities
  var recvAudioCaps = RTCRtpReceiver.getCapabilities('audio');
  var recvVideoCaps = RTCRtpReceiver.getCapabilities('video');   
// Retrieve the audio and video sender capabilities
  var sendAudioCaps = RTCRtpSender.getCapabilities('audio'); 
  var sendVideoCaps = RTCRtpSender.getCapabilities('video'); 

  mySignaller.myOfferTracks({
    // The initiator offers its receiver and sender capabilities. 
    "recvAudioCaps": recvAudioCaps, 
    "recvVideoCaps": recvVideoCaps,
    "sendAudioCaps": sendAudioCaps,
    "sendVideoCaps": sendVideoCaps 
  }, function(answer) {
    // The responder answers with its receiver capabilities

    // Derive the send and receive parameters
    var audioSendParams = myCapsToSendParams(sendAudioCaps, answer.recvAudioCaps); 
    var videoSendParams = myCapsToSendParams(sendVideoCaps, answer.recvVideoCaps); 
    var audioRecvParams = myCapsToRecvParams(recvAudioCaps, answer.sendAudioCaps);
    var videoRecvParams = myCapsToRecvParams(recvVideoCaps, answer.sendVideoCaps); 
    audioSender.send(audioSendParams);
    videoSender.send(videoSendParams);
    audioReceiver.receive(audioRecvParams);
    videoReceiver.receive(videoRecvParams);

    // Now we can render/play
    // audioReceiver.track and videoReceiver.track.
  });
}
    </pre>
   <pre xml:space="preserve" class='example highlight'>
// Assume we already have a way to signal, a transport (RTCDtlsTransport)
// and audio and video tracks. This is an example of how to answer an
// offer with audio and video tracks, and begin sending and receiving them. 
// The example assumes that RTP and RTCP are multiplexed. 
function myAccept(mySignaller, remote, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver(transport, 'audio');
  var videoReceiver = new RTCRtpReceiver(transport, 'video');

// Retrieve the send and receive capabilities
  var recvAudioCaps = RTCRtpReceiver.getCapabilities('audio');
  var recvVideoCaps = RTCRtpReceiver.getCapabilities('video');
  var sendAudioCaps = RTCRtpSender.getCapabilities('audio'); 
  var sendVideoCaps = RTCRtpSender.getCapabilities('video'); 

  mySignaller.myAnswerTracks({
    "recvAudioCaps": recvAudioCaps,
    "recvVideoCaps": recvVideoCaps,
    "sendAudioCaps": sendAudioCaps,
    "sendVideoCaps": sendVideoCaps
  });

    // Derive the send and receive parameters using Javascript functions defined in Section 17.2.
    var audioSendParams = myCapsToSendParams(sendAudioCaps, remote.recvAudioCaps);
    var videoSendParams = myCapsToSendParams(sendVideoCaps, remote.recvVideoCaps);
    var audioRecvParams = myCapsToRecvParams(recvAudioCaps, remote.sendAudioCaps);
    var videoRecvParams = myCapsToRecvParams(recvVideoCaps, remote.sendVideoCaps);
    audioSender.send(audioSendParams);
    videoSender.send(videoSendParams);
    audioReceiver.receive(audioRecvParams);
    videoReceiver.receive(videoRecvParams);

  // Now we can render/play
  // audioReceiver.track and videoReceiver.track.
}
  </pre>
  </section>

</section>
        <section id="msrtcconfconfig*">
		<h2><dfn>MSRTCConfConfig</dfn> Interface</h2>
                <p>The <code>MSRTCConfConfig</code> interface assists in managing bandwidth estimation.</p>
            <section id="msrtcconfconfig-overview*">
                <h3>Overview</h3>
                <p>
                    An <code><a>MSRTCConfConfig</a></code> object provides configuration for <code><a>RTCIceGatherer</a></code>
                    objects.
                </p>
            </section>
            <section id="msrtcconfconfig-operation*">
                <h3>Operation</h3>
                <p>An <code><a>MSRTCConfConfig</a></code> object is (optionally) constructed from an <code>MSRTCConfSettings</code>
		object.</p>
            </section>
            <section id="msrtcconfconfig-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="[Constructor(optional MSRTCConfSettings settings)] interface MSRTCConfConfig">
                    <dt>attribute EventHandler? onmsvideoreceivers</dt>
                    <dd><p>This event handler, of event handler type <code>msvideoreceivers</code>,
                    MUST be fired when the number of potential video receivers changes.
                    </p></dd>
                </dl>
            </section>
            <section id="MSRTCConfSettings*">
	    <h3><dfn>MSRTCConfSettings</dfn> Dictionary</h3>
                 <p>The <code>MSRTCConfSettings</code> dictionary provides configuration settings for the conference.</p>

                 <dl title='dictionary MSRTCConfSettings' class='idl'>
                    <dt>boolean msConfMode = false</dt>
                    <dd><p><code>msConfMode</code> has the value <code>true</code> if the 
                      configuration is associated with a
                      conferencing server, <code>false</code> otherwise. By default
                      <code>msConfMode</code> is set to <code>false</code>.</p></dd>
		     <dt>MSRTCSystemSettings msSysSettings</dt>
		     <dd><p>The configuration corresponding to this conference.</p></dd
                 </dl>
            </section>
            <section id="MSRTCSystemSettings*">
	    <h3><dfn>MSRTCSystemSettings</dfn> Dictionary</h3>
                 <p>The <code>MSRTCSystemSettings</code> dictionary provides system configuration information.</p>

                 <dl title='dictionary MSRTCSystemSettings' class='idl'>
                    <dt>sequence&lt;MSDeviceDriver> hardwareVideoEncoderBlockList</dt>
                    <dd><p>A sequence of dictionaries indicating graphics drivers that do not have compatible hardware encoding support.</p></dd>
                 </dl>
            </section>
            <section id="MSDeviceDriver*">
            <h3><dfn>MSDeviceDriver</dfn> Dictionary</h3>
                 <p>The <code>MSDeviceDriver</code> dictionary provides information on unsupported devices, such as the identifier and
	         device driver versions.</p>

                 <dl title='dictionary MSDeviceDriver' class='idl'>
		    <dt>DOMString vendorId</dt>
		    <dd><p>The vendor ID.</p></dd>
                    <dt>DOMString deviceId</dt>
                    <dd><p>The PNP Device ID in hex format. Zero (0) means all.</p></dd>
                    <dt>DOMString deviceDriverVersionRangeMin</dt>
                    <dd><p>Starting graphics driver version (inclusive) to be blocked.</p></dd>
		    <dt>DOMString deviceDriverVersionRangeMax</dt>
                    <dd><p>Ending graphics driver version (inclusive) to be blocked.</p></dd>
                 </dl>
            </section>
  <section id="msvideoreceivers-interface-definition*">
      <h3>msvideoreceivers</h3>

        <p>The <code>msvideoreceivers</code> event of the <code><a>MSRTCConfConfig</a></code> object uses
        the <code><a>MSVideoReceiversEvent</a></code> interface.</p>

        <p>Firing a <code>msvideoreceivers</code> event named <var>e</var>
        with <code>maxReceivers</code> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code><a>MSVideoReceiversEvent</a></code> interface with the
        <var>maxReceivers</var> attribute
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="MSVideoReceiversEventInit" title=
        "[Constructor(DOMString type, MSVideoReceiversEventInit eventInitDict)] interface MSVideoReceiversEvent : Event">
          <dt>readonly attribute unsigned long maxReceivers</dt>
          <dd>
            <p>The <var>maxReceivers</var> attribute contains the maximum number of video receivers.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary MSVideoReceiversEventInit : EventInit">
          <dt>unsigned long maxReceivers</dt>
          <dd>
            <p>The <var>maxReceivers</var> attribute contains the maximum number of video receivers.
            </p>
          </dd>
        </dl>
   </section>
</section>

<section id="rtcrtpdictionaries*">
  <h2>Dictionaries related to Rtp</h2>

  <section id="rtcrtpcapabilities*">
  <h3><dfn>RTCRtpCapabilities</dfn> Dictionary</h3>

<p>The <code>RTCRtpCapabilities</code> object expresses the capabilities of <code><a>RTCRtpSender</a></code> and 
<code><a>RTCRtpReceiver</a></code> objects.
Features which are mandatory to implement in [[!RTP-USAGE]], such as RTP/RTCP multiplexing [[!RFC5761]], 
audio/video multiplexing  [[!RTP-MULTI-STREAM]] 
and reduced size RTCP [[!RFC5506]] are assumed to be available and are therefore 
not included in <code><a>RTCRtpCapabilities</a></code>, 
although these features can be set via <code><a>RTCRtpParameters</a></code>.</p>

    <dl title='dictionary RTCRtpCapabilities' class='idl'>
      <dt>sequence&lt;RTCRtpCodecCapability> codecs</dt>
      <dd><p>Supported codecs.</p></dd>
      <dt>sequence&lt;RTCRtpHeaderExtension> headerExtensions</dt>
      <dd><p>Supported RTP header extensions.</p></dd>
      </p></dd>
      <dt>sequence&lt;DOMString> fecMechanisms</dt>
      <dd>
                        <p>Supported Forward Error Correction (FEC) mechanisms.  Values include
                        "red", "red+ulpfec", "x-ulpfecuc" and "flexfec".
      </dd>
    </dl>

 </section>

  <section id="rtcrtcpfeedback*">
  <h3><dfn>RTCRtcpFeedback</dfn> Dictionary</h3>
    <p><code>RTCRtcpFeedback</code> provides information on RTCP feedback messages.
    Microsoft Edge ORTC supports the Generic NACK [[!RFC4585]] and PLI [[!RFC4585]] feedback messages, as well as the Google Receiver
    Estimated Maximum Bitrate ("goog-remb") feedback message [[REMB]].
    In addition, [[MS-SDPEXT]] Section 3.1.5.30.2 describes Microsoft proprietary feedback messages supported in Edge ORTC, including the
    Dominant Speaker History Notification (dsh), Video Source Request (src), 
    and Picture Loss Indicator (x-pli) messages.
    </p>
    <dl title='dictionary RTCRtcpFeedback' class='idl'>
      <dt>DOMString type</dt>
      <dd><p>Valid values for <var>type</var> are the "RTCP Feedback" Attribute Values enumerated in [[!IANA-SDP-14]] ("ack", "ccm", "nack", etc.),
      as well as "goog-remb" [[!REMB]]</p></dd>
      <dt>DOMString parameter</dt>
      <dd>
          <p>
              For a <var>type</var> of "ack" or "nack", valid values for <var>parameter</var> are the
              "ack" and "nack" Attribute Values enumerated in [[!IANA-SDP-15]] ("sli", "rpsi", etc.).
              For the Generic NACK feedback message defined in [[!RFC4585]] Section 6.2.1,
              the <var>type</var> attribute is set to "nack" and the <var>parameter</var> attribute is unset.
              For a <var>type</var> of "ccm", valid values for <var>parameter</var> are the
             "Codec Control Messages" enumerated in [[!IANA-SDP-19]] ("fir", "tmmbr" (includes "tmmbn"), etc.).
          </p>
      </dd>
    </dl>
  </section>

  <section id="rtcrtpcodeccapability*">
  <h3><dfn>RTCRtpCodecCapability</dfn> Dictionary</h3>
    <p><code>RTCRtpCodecCapability</code> provides information on the capabilities of a codec.</p>

     <dl class="idl" title=
  "typedef object Dictionary">
        </dl>

     <dl class="idl" title=
  "typedef octet payloadtype">
        </dl>

    <dl class="idl" title="dictionary RTCRtpCodecCapability">
      <dt>DOMString name</dt>
        <dd><p>The MIME media type.  Valid types are
        listed in [[!IANA-RTP-2]].</p></dd>
      <dt>DOMString kind</dt>
        <dd><p>The media supported by the codec: "audio", "video" or "" for both.</p></dd>
      <dt>unsigned long clockRate</dt>
        <dd><p>Codec clock rate expressed in Hertz, null if unset.</p></dd>
      <dt>payloadtype preferredPayloadType</dt>
      <dd><p>The preferred RTP payload type for the codec denoted by <var>RTCRtpCodecCapability.name</var>.  
      This attribute was added to make it possible for the sender and receiver to pick a
      matching payload type when creating sender and receiver parameters.
      When returned by <code>RTCRtpSender.getCapabilities()</code>,  <var>RTCRtpCapabilities.codecs.preferredPayloadtype</var>
      represents the preferred RTP payload type for sending.
      When returned by <code>RTCRtpReceiver.getCapabilities()</code>,  <var>RTCRtpCapabilities.codecs.preferredPayloadtype</var> 
      represents the preferred RTP payload type for receiving. 
      To avoid payload type conflicts, each value of <var>RTCRtpCodecCapability.name</var> should have a unique value of 
      <var>RTCRtpCodecCapability.preferredPayloadtype</var>.
      </p></dd>
      <dt>unsigned long maxptime</dt>
      <dd><p>The maximum packetization time supported by the <code><a>RTCRtpReceiver</a></code>.</p></dd>
      <dt>unsigned long ptime</dt>
      <dd>
        <p>The preferred duration of media represented by a packet in milliseconds for the <code><a>RTCRtpSender</a></code> or
        <code><a>RTCRtpReceiver</a></code>.  For an <code><a>RTCRtpReceiver</a></code>, must be less than the value of 
        <var>maxptime</var>.</p>
      </dd>
      <dt>unsigned long numChannels</dt>
        <dd><p>The number of channels supported (e.g. stereo). 
        For video, this will be unset.</p></dd>
      <dt>sequence&lt;RTCRtcpFeedback> rtcpFeedback</dt>
      <dd><p>Transport layer and codec-specific feedback messages for this codec.</p></dd>
      <dt>Dictionary parameters</dt>
        <dd><p>Codec-specific parameters that must be signaled to the remote party.</p></dd>
      <dt>Dictionary options</dt>
        <dd><p>Codec-specific parameters available for signaling.</p></dd>
      <dt>unsigned short maxTemporalLayers = 0</dt>
      <dd><p>Maximum number of temporal layer extensions supported by this codec (e.g. a value of 1 indicates support for up to 2 temporal layers).  A value of 0 indicates no support for temporal scalability.</p></dd>
      <dt>unsigned short maxSpatialLayers = 0</dt>
      <dd><p>Maximum number of spatial layer extensions supported by this codec (e.g. a value of 1 indicates support for up to 2 spatial layers).  A value of 0 indicates no support for spatial scalability.</p></dd>
      <dt>boolean svcMultiStreamSupport</dt>
      <dd><p>Whether the implementation can send SVC layers utilizing distinct SSRCs.
      Unset for audio codecs.  For video codecs, only set if the codec supports scalable video coding with
      multiple streams.
      </p></dd>
    </dl>

  <section id="codec-capabilities*">
    <h3>Edge capabilities</h3>

    <p>This section describes the capabilities supported by the Microsoft Edge ORTC API implementation.  These include
    capabilites relating to codecs, RTCP feedback, Retransmission (RTX)[[!RFC4588]], header extensions and Forward Error Correction (FEC).</p>  
    <p>As noted in [[!RFC7874]], the G.711, DTMF [[!RFC4733]], Opus [[!RFC6176]][[!RFC7587]] and Comfort Noise (CN) [[!RFC3389]] codecs are 
    mandatory-to-implement in WebRTC.  
    The Microsoft Edge ORTC implementation supports the G.711, DTMF, CN, Opus and SILK [[SILK]] 
    audio codecs. G.722 is supported on ARM-based devices only.</p>
    <p>
    <p>As noted in [[!RFC7742]], the H.264 [[!RFC6184]] and VP8 [[!RFC6386]][[!RFC7741]]
    video codecs are mandatory-to-implement in WebRTC.
    Microsoft Edge currently supports the H.264UC video codec [[MS-H264PF]] which is based on H.264/SVC [[RFC6190]].
    Work on support for H.264/AVC is in progress.</p>
    <p>The capabilities of codecs supported by Microsoft Edge are described below.</p>

  <section id="g711-settings*">
     <h3>G.711</h3>
<p>Since G.711 is an audio codec
there is no support for multi-stream transport or temporal or spatial scalability.
Only mono operation is supported (<var>numChannels</var> set to 1).
As noted in [[!RFC3551]] Section 6, G.711 has
been assigned static payload types for the PCMU and PCMA variants, which Microsoft Edge provides as the preferred payload type.</p>

<p>The Dominant Speaker History Notification (dsh) application RTCP feedback message allows a mixer to provide dominant speaker history.  The packet format is
described in [[MS-RTP]] Section 2.2.12.3, and RTCP feedback messages supported by Edge (including dsh) are described in [[MS-SDPEXT]] Section 3.1.5.30.2.
Since this application RTCP feedback message is only useful when communicating with a Skype for Business (SfB) mixer, in other situations this proprietary feedback message should not be 
configured within <code>RTCRtpParameters</code> passed as an argument in <code>send()</code> or <code>receive()</code>. 
</p>

    <section id="g711-example*">
     <h4>Capabilities</h4>

   <pre xml:space="preserve" class='example highlight'>
{
  "name": "PCMU",
  "kind": "audio",
  "clockRate": 8000,
  "preferredPayloadType": 0,
  "maxptime": 60,
  "ptime": 20,
  "numChannels": 1,
  "rtcpFeedback": [
    {
      "type": "x-message",
      "parameter": "app send:dsh recv:dsh"
    }
  ],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
},
{
  "name": "PCMA",
  "kind": "audio",
  "clockRate": 8000,
  "preferredPayloadType": 8,
  "maxptime": 60,
  "ptime": 20,
  "numChannels": 1,
  "rtcpFeedback": [
    {
      "type": "x-message",
      "parameter": "app send:dsh recv:dsh"
    }
  ],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
}
   </pre>
    </section>
  </section>

  <section id="g722-capabilities*">
  <h3>G.722</h3>
<p>The G.722 audio codec does not include any parameters or options in its capabilities.
Since it is an audio codec there is no support for
multi-stream transport or temporal or spatial scalability.
As noted in [[!RFC3551]] Section 6, G.722 has
been assigned a static payload type, which Microsoft Edge provides as the preferred payload type.</p>
<p>While G.722-stereo is described in [[MS-RTP]] Section 2.2.1.1 and [[MS-SDPEXT]] Section 3.5.1.3, the
G.722 implementation in Edge only supports mono (<var>numChannels</var> set to 1).</p>
 
    <section id="g722-example*">
     <h4>Capabilities</h4>
   <pre xml:space="preserve" class='example highlight'>
{
  "name": "G722",
  "kind": "audio",
  "clockRate": 8000,
  "preferredPayloadType": 9,
  "maxptime": 60,
  "ptime": 20,
  "numChannels": 1,
  "rtcpFeedback": [
    {
      "type": "x-message",
      "parameter": "app send:dsh recv:dsh"
    }
  ],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
}
   </pre>
    </section>
  </section>

  <section id="cn-capabilities*">
  <h3>Comfort Noise</h3>
<p>The Comfort Noise (CN) audio codec does not include any parameters or options in its capabilities and settings.
Since it is an audio codec, it does not support multi-stream transport or
temporal or spatial scalability.  Only mono operation is supported (<var>numChannels</var> set to 1).
<var>clockRate</var> values of 8000 and 16000 are supported. 
As noted in [[!RFC3389]], CN has
been assigned a static payload type for a <var>clockRate</var> value of 8000, which Microsoft Edge provides as the preferred payload type.
For a <var>clockRate</var> value of 16000, Microsoft Edge assigns a dynamic payload type.</p>
<p>When CN is configured for use along with the G.711, G.722 and SILK codecs, CN <var>clockRate</var> is set to 8000.
Since the Microsoft Edge implementation of Opus does not support Discontinuous Transmission (DTX), 
it is possible (though not advisable if interoperability is desired) to use CN along with Opus,
in which case the CN value of <var>clockRate</var> to 16000 would be configured.</p>  

    <section id="cnn-example*">
     <h4>Capabilities</h4>
   <pre xml:space="preserve" class='example highlight'>
{
  "name": "CN",
  "kind": "audio",
  "clockRate": 8000,
  "preferredPayloadType": 13,
  "maxptime": 0,
  "ptime": 0,
  "numChannels": 1,
  "rtcpFeedback": [],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
},
{
  "name": "CN",
  "kind": "audio",
  "clockRate": 16000,
  "preferredPayloadType": 118,
  "maxptime": 0,
  "ptime": 0,
  "numChannels": 1,
  "rtcpFeedback": [],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
}
   </pre>
    </section>
  </section>

  <section id="dtmf-codec-capabilities*">
    <h3>DTMF</h3>
    <p>The DTMF audio codec only includes a single parameter in its capabilities, as noted below.
Since it is a mono audio codec, only a single channel is supported and
it does not support multi-stream transport or temporal or spatial scalability.
As noted in [[!RFC4733]] DTMF utilizes a dynamic payload type so that
Microsoft Edge assigns a preferred payload type in the dynamic range.</p>
<p>As noted in [[MS-DTMF]], DTMF cannot be used with the Microsoft implementation of Redundant Audio Data [[MS-RTPRADEX]]. 
The Microsoft Edge implementation of DTMF supports events 0-15, as described in [[!RFC4733]].</p>
<p>The single capability and setting supported by DTMF is defined in [[!RFC4733]] Section 2.4:</p>

      <table class="simple">
        <thead>
          <tr>
            <th>Property Name</th>

            <th>Values</th>

            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr id="def-events*">
            <td><dfn>events</dfn></td>

            <td>
              <code>DOMString</code>
            </td>

            <td>An indication of what telephony events are supported (or configured).
           Events are listed as one or more comma-separated
           elements.  Each element can be either a single integer providing the
           value of an event code or an integer followed by a hyphen and a
           larger integer, presenting a range of consecutive event code values.
           The list does not have to be sorted.  No white space is allowed in
           the argument.  The union of all of the individual event codes and
           event code ranges designates the complete set of event numbers
           supported by the implementation.
            </td>
            </tr>
        </tbody>
      </table>

    <section id="dtmfcap-example*">
     <h4>Capabilities</h4>
   <pre xml:space="preserve" class='example highlight'>
{
  "name": "telephone-event",
  "kind": "audio",
  "clockRate": 8000,
  "preferredPayloadType": 101,
  "maxptime": 0,
  "ptime": 0,
  "numChannels": 1,
  "rtcpFeedback": [],
  "parameters": {
    "events": "0-16"
  },
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
}
   </pre>
    </section>
  </section>

  <section id="opus-codec-capabilities*">
    <h3>Opus</h3>
<p>The Microsoft Edge implementation of Opus does not support any parameters or options in Opus capabilities. 
While [[!RFC7587]] Section 7 describes Opus settings such as <var>stereo</var>, <var>useinbandfec</var> and <var>usedtx</var>, 
the Microsoft Edge implementation of Opus currently only supports mono operation, cannot support Discontinous Operation (DTX) and does not support inband FEC.
While it is possible to configure external FEC (RED) for use
with Opus to enhance robustness (distance of 3 is supported versus a distance of 1 for inband FEC), this will not interoperate with other Opus implementations. 
Interoperability issues may also be experienced if CN is configured to provide voice activity detection.</p>
<p>Since it is an audio codec, Opus does not support multi-stream transport or temporal or spatial scalability.
While a <var>numChannels</var> value of 2 is supported, currently the <var>numChannels</var> value does not affect Opus codec operation (only mono is supported, regardless of the value of <var>numChannels</var>).  
Since Opus utilizes a dynamic payload type
Microsoft Edge assigns a preferred payload type in the dynamic range.
Currently <var>clockRate</var> can only be set to 48000.</p>

    <section id="opuscap-example*">
     <h4>Capabilities</h4>
   <pre xml:space="preserve" class='example highlight'>
{
  "name": "opus",
  "kind": "audio",
  "clockRate": 48000,
  "preferredPayloadType": 102,
  "maxptime": 60,
  "ptime": 20,
  "numChannels": 2,
  "rtcpFeedback": [
    {
      "type": "x-message",
      "parameter": "app send:dsh recv:dsh"
    }
  ],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
}
   </pre>
    </section>
  </section> 


  <section id="silk-codec-capabilities*">
    <h3>SILK</h3>
    <p>For the SILK audio codec, Microsoft Edge does not support
any parameters or options within the cabilities.
Since it is an audio
codec, SILK does not support multi-stream transport or temporal or spatial scalability.
Only mono operation is supported (<var>numChannels</var> set to 1), along with
<var>clockRate</var> values of 8000 and 16000.
Since SILK utilizes a dynamic payload type
Microsoft Edge assigns a preferred payload type in the dynamic range.</p>
<p>SILK settings are described in [[MS-SDPEXT]] Section 3.1.5.3.  This includes a discussion of 8000 and 16000 clock rates, as well as
the <var>usedtx</var> and
<var>useinbandfec</var> settings.  However, neither inband FEC or DTX is configurable in Microsoft Edge,
although external FEC (RED) and CN may be configured.</p> 

    <section id="silkcap-example*">
     <h4>Capabilities</h4>
   <pre xml:space="preserve" class='example highlight'>
{
  "name": "SILK",
  "kind": "audio",
  "clockRate": 8000,
  "preferredPayloadType": 103,
  "maxptime": 60,
  "ptime": 20,
  "numChannels": 1,
  "rtcpFeedback": [
    {
      "type": "x-message",
      "parameter": "app send:dsh recv:dsh"
    }
  ],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
},
{
  "name": "SILK",
  "kind": "audio",
  "clockRate": 16000,
  "preferredPayloadType": 104,
  "maxptime": 100,
  "ptime": 20,
  "numChannels": 1,
  "rtcpFeedback": [
    {
      "type": "x-message",
      "parameter": "app send:dsh recv:dsh"
    }
  ],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
}
   </pre>
    </section>
</section>

  <section id="red-codec-capabilities*">
    <h3>RED</h3>
<p>For use with audio codecs, Microsoft Edge supports Redundant Audio Data (RED) [[!RFC2198]] with extensions described in [[MS-RTPRADEX]].
Since it is only for use with audio, RED does not support multi-stream transport or temporal or spatial scalability.
Only a single channel is supported. 
RED can be used to protect the G.711, G.722, SILK, CN and Opus payload types.  
When RED is configured, it is used to protect all configured audio codecs using only a single dynamically allocated RED payload type. 
There are no configuration parameters to set.  
</p>
      <div class="note">
<p>Edge Interop Note: As noted in [[MS-RTPRADEX]], within Microsoft's implementation of RED, only a single block of redundant audio 
data is supported, along with a block of primary data.
The primary audio block and redundant audio block MUST use the same codec.
In addition to advertising RED as an audio codec, Microsoft Edge capabilities also include RED as a mechanism for 
carriage of Forward Error Correction (FEC), since FEC is provided
in the redundant audio data block, with a maximum distance of 3 (e.g. "fecMechanisms":["RED"]").
Since the FEC mechanism utilized with RED is proprietary, RED should not be configured within <code>RTCRtpParameters</code> 
when interoperation with other WebRTC implementations is desired.
</p>
      </div>
    <section id="redcap-example*">
     <h4>Capabilities</h4>
    <pre xml:space="preserve" class='example highlight'>
{
  "name": "RED",
  "kind": "audio",
  "clockRate": 8000,
  "preferredPayloadType": 97,
  "maxptime": 0,
  "ptime": 0,
  "numChannels": 1,
  "rtcpFeedback": [],
  "parameters": {},
  "options": {},
  "maxTemporalLayers": 0,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
}
    </pre>
    </section>
</section>

  <section id="h264uc-codec-capabilities*">
    <h3>H.264UC</h3>
<p>Microsoft Edge supports the H.264UC [[MS-H264PF]] video codec, along with an end-to-end Forward Error Correction (FEC) scheme.
For both H.264UC and FEC, Microsoft Edge assigns a preferred payload type in the dynamic range.</p>
    <section id="h264ucp-example*">
     <h4>Capabilities</h4>
<p>Microsoft Edge returns the example <code><a>RTCRtpCapabilities</a></code> object below
in response to a call to <code>getCapabilities("video")</code>.  H.264UC supports a maximum of 3 temporal layers using
multi-stream transport, along with spatial simulcast.  
</p>
      <div class="note">
<p>
The H.264UC codec utilizes MRST transport, along with packetization-mode 1. 
Temporal scalability (a maximum of 3 layers) and spatial simulcast (a maximum of 2 layers) are automatically
enabled and the encoding is dynamically adjusted based on network conditions.  As a result, 
<var>rtcpFeedback</var>, <var>parameters</var> and <var>options</var> SHOULD be configured as they
are provided in the <code><a>RTCRtpCapabilities</a></code> object shown below. 
Since H.264UC does not support SRST transport or spatial scalability, <var>svcMultiStreamSupport</var> MUST be set to true
and <var>maxSpatialLayers</var> MUST be set to 0.  Note that setting  <var>maxTemporalLayers</var> does not have an 
effect. 
</p>
    </div>
    <pre xml:space="preserve" class='example highlight'>
{
  "codecs": [
    {
      "name": "X-H264UC",
      "kind": "video",
      "clockRate": 90000,
      "preferredPayloadType": 122,
      "maxptime": 0,
      "ptime": 0,
      "numChannels": 1,
      "rtcpFeedback": [
        {
          "type": "x-message",
          "parameter": "app send:src,x-pli recv:src,x-pli"
        }
      ],
      "parameters": {
        "packetization-mode": "1",
        "mst-mode": "NI-TC"
      },
      "options": {},
      "maxTemporalLayers": 3,
      "maxSpatialLayers": 0,
      "svcMultiStreamSupport": true
    },
    {
      "name": "x-ulpfecuc",
      "kind": "video",
      "clockRate": 90000,
      "preferredPayloadType": 123,
      "maxptime": 0,
      "ptime": 0,
      "numChannels": 1,
      "rtcpFeedback": [],
      "parameters": {},
      "options": {},
      "maxTemporalLayers": 0,
      "maxSpatialLayers": 0,
      "svcMultiStreamSupport": false
    }
  ],
  "headerExtensions": [
    {
      "kind": "video",
      "uri": "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
      "preferredId": 1,
      "preferredEncrypt": false
    },
    {
      "kind": "video",
      "uri": "http://skype.com/experiments/rtp-hdrext/fast_bandwidth_feedback#version_2",
      "preferredId": 3,
      "preferredEncrypt": false
    }
  ],
  "fecMechanisms": []
}
   </pre>

      <div class="note">
<p>Edge Interop Note: H.264UC supports an end-to-end Forward Error Correction (FEC) scheme known as "ULPFECUC", described in [[MS-SDPEXT]] 3.1.5.3.
Configuration of "ULPFECUC" is recommended when H.264UC is configured since this improves resilience against packet loss.
For resilience, it is also recommended that the x-pli and src RTCP feedback messages be configured along with
H.264UC.  The x-pli RTCP feedback message is described in [[MS-RTP]] Section 2.2.12.1; it differs from the standard PLI
message defined in [[!RFC4585]] Section 6.3.1 in that it contains only one Feedback Control Information (FCI) field.
</p>
<p>
There are no configurable settings for "ULPFECUC", and when using it, the <var>fecMechanisms</var> attribute is set to null as noted above.
The "src" proprietary RTCP feedback message advertised as capability corresponds to the Video Source Request (VSR) RTCP feedback message
described in [[MS-RTP]] Section 2.2.12.2.
</p>
    </div>
    </section>
</section>

  <section id="h264-avc*">
    <h3>H.264</h3>
    <p>H.264/AVC is on by default in Windows Insider preview. Microsoft Edge assigns a preferred payload type in the dynamic range.
Currently simulcast is not supported for H.264/AVC. The following capabilities are supported for H.264/AVC,
as described in [[RFC6184]] Section 8.1, and [[!RFC7742]] Section 6.2:</p>

                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="def-profile-level-id*">
                                    <td><dfn>profile-level-id</dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver/Sender</td>
                                    <td>This parameter describes the maximum capability of the decoder 
                                    (for an <code><a>RTCRtpReceiver</a></code>) and an encoder (for an <code><a>RTCRtpSender</a></code>). 
                                    Microsoft Edge currently advertises a value of "42c02a" for this capability.</td>
                                </tr>
                                <tr id="def-packetization-mode*">
                                    <td><dfn>packetization-mode</dfn></td>
                                    <td><code>sequence&lt;unsigned short&gt;</code></td>
                                    <td>Receiver/Sender</td>
                                    <td>
                                        A sequence of unsigned shorts, each ranging from 0 to 2, indicating supported <var>packetizationMode</var> values.
                                        As noted in [[!RFC7742]] Section 6.2, support for packetization-mode 1 is mandatory.
                                        Microsoft Edge only supports a packetization-mode value of 1. 
                                    </td>
                                </tr>
                                </tr>
                                <tr id="def-other-h264-params*">
                                    <td>maxMbps, maxFs, maxBr, maxFps</td>
                                    <td>
                                        <code>unsigned long long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>
                                        As noted in [[!RFC7742]] Section 6.2, these parameters
                                        allow the implementation to specify that the decoder can support
                                        certain features of H.264 at higher rates and values than those
                                        indicated by <var>profileLevelId</var>. Microsoft Edge currently
                                        advertises the following capabilities (and values): 
                                        maxMbps (3600), maxFs (240), maxBr (208) and maxFps (1500).
                                    </td>
                                </tr>
                            </tbody>
                        </table>

                       <p>The following settings are defined for H.264:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="sec-profile-level-id*">
                                    <td><a>profile-level-id</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>This parameter indicates the configuration of the stream to be sent, as noted in [[RFC6184]] Section 8.2.2.
                                    It MUST be supported, as noted in [[!RFC7742]] Section 6.2.
                                    Microsoft Edge currently will not change the sender encoding based on this setting.</td> 
                                </tr>
                                <tr id="sec-packetization-mode*">
                                    <td><a>packetization-mode</a></td>
                                    <td><code>unsigned short</code></td>
                                    <td>Sender</td>
                                    <td>
                                        An unsigned short ranging from 0 to 2, indicating the <var>packetizationMode</var> value to be used by the sender.  
                                        Microsoft Edge only supports a <var>packetizationMode</var> value of 1. 
                                    </td>
                                </tr>
                              </tbody>
                          </table>
<p>Microsoft Edge currently does not permitting setting the maxFs, maxMbps, maxBr or MaxFps values.</p>
    <section id="h264-example*">
     <h4>Capabilities</h4>
<p>Microsoft Edge returns the example <code><a>RTCRtpCapabilities</a></code> object below
in response to a call to <code>getCapabilities("video")</code>.</p>
    <pre xml:space="preserve" class='example highlight'>
{
  "name": "H264",
  "kind": "video",
  "clockRate": 90000,
  "preferredPayloadType": 107,
  "maxptime": 0,
  "ptime": 0,
  "numChannels": 1,
  "rtcpFeedback": [
    {
      "type": "nack",
      "parameter": ""
    },
    {
      "type": "nack",
      "parameter": "pli"
    },
    {
      "type": "goog-remb",
      "parameter": ""
    }
  ],
  "parameters": {
    "profile-level-id": "42C02A",
    "packetization-mode": "1"
  },
  "options": {},
  "maxTemporalLayers": 3,
  "maxSpatialLayers": 0,
  "svcMultiStreamSupport": false
}
    </pre>
  </section>
 </section>
  <section id="vp8-capabilities*">
    <h3>VP8</h3>
    <p>VP8 support is now available within Windows Insider Preview. 
Microsoft Edge assigns a preferred payload type in the dynamic range.
Currently simulcast is not supported for VP8.
The following capabilities are supported for VP8,
as described in [[RFC7741]] Section 6.1, and [[!RFC7742]] Section 6.1:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-max-fr*">
                <td><dfn><code>max-fr</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Receiver</td>
                <td>This parameter indicates the maximum frame rate in frames per second
                that the decoder is capable of decoding.</td>
              </tr>
              <tr id="def-max-fs*">
                <td><dfn><code>max-fs</code></dfn></td>
                <td><code>unsigned long long</code></td>
                <td>Receiver</td>
                <td>This parameter indicates the maximum frame size in macroblocks that
                the decoder is capable of decoding.</td>
              </tr>
            </tbody>
          </table>
<p>The following sender settings are supported for VP8:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="sec-max-fr*">
                <td>
                  <a>max-fr</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>This parameter indicates the maximum frame rate in frames per second
                that the decoder is capable of decoding.</td>
              </tr>
              <tr id="sec-max-fs*">
                <td>
                  <a>max-fs</a>
                </td>
                <td><code>unsigned long long</code></td>
                <td>Sender</td>
                <td>This parameter indicates the maximum frame size in macroblocks that
                the decoder is capable of decoding.</td>
              </tr>
            </tbody>
          </table>
    <section id="vp8-example*">
     <h4>Capabilities</h4>
<p>Microsoft Edge returns the example <code><a>RTCRtpCapabilities</a></code> object below
in response to a call to <code>RTCRtpReceiver.getCapabilities("video")</code>.</p>
    <pre xml:space="preserve" class='example highlight'>
{
  "name": "VP8",
  "kind": "video",
  "clockRate": 90000,
  "preferredPayloadType": 100,
  "maxptime": 0,
  "ptime": 0,
  "numChannels": 1,
  "rtcpFeedback": [
    {
      "type": "nack",
      "parameter": ""
    },
    {
      "type": "nack",
      "parameter": "pli"
    },
    {
      "type": "goog-remb",
      "parameter": ""
    }
  ],
  "parameters": {
    "max-fr": "30",
    "max-fs": "3600"
   },
   "options": {},
   "maxTemporalLayers": 0,
   "maxSpatialLayers": 0,
   "svcMultiStreamSupport": false
}
    </pre>
  </section>
 </section>
                    <section id="rtx-codec-capability*">
                        <h3>RTX</h3>
                        <p>The following capability is defined for "rtx", as noted in [[!RFC4588]] Section 8.6:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="def-rtxtime*">
                                    <td><dfn>rtx-time</dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>
                            As defined in [[!RFC4588]], the default time in milliseconds (measured from the
                            time a packet was first sent) that the sender keeps an RTP packet
                            in its buffers available for retransmission.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
<p>The "rtx" codec has a single setting exposed in Microsoft Edge:.</p> 
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="def-apt*">
                                    <td><dfn>apt</dfn></td>
                                    <td>
                                        <code>payloadType</code>
                                    </td>
                                    <td>Receiver/Sender</td>
                                    <td>
                            As defined in [[!RFC4588]], the associated payload type of the
                            original stream being retransmitted.  There will be an "rtx"
                            entry in <code>RTCRtpParameters.codecs[]</code> for each media
                            codec that can be retransmitted, each with their own <code>apt</code>
                            parameter.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
    <section id="rtx-example*">
     <h4>Capabilities</h4>
<p>Microsoft Edge returns the example <code><a>RTCRtpCapabilities</a></code> object below
in response to a call to <code>RTCRtpReceiver.getCapabilities("video")</code>. Note that multiple RTX codec capabilities
are returned, one for each video codec that can be retransmitted.</p>
    <pre xml:space="preserve" class='example highlight'>
{
  "codecs": [
    {
      "name": "H264",
      "kind": "video",
      "clockRate": 90000,
      "preferredPayloadType": 107,
      "maxptime": 0,
      "ptime": 0,
      "numChannels": 1,
      "rtcpFeedback": [
        {
          "type": "nack",
          "parameter": ""
        },
        {
          "type": "nack",
          "parameter": "pli"
        },
        {
          "type": "goog-remb",
          "parameter": ""
        }
      ],
      "parameters": {
        "profile-level-id": "42C02A",
        "packetization-mode": "1"
      },
      "options": {},
      "maxTemporalLayers": 3,
      "maxSpatialLayers": 0,
      "svcMultiStreamSupport": false
    },
    {
      "name": "VP8",
      "kind": "video",
      "clockRate": 90000,
      "preferredPayloadType": 100,
      "maxptime": 0,
      "ptime": 0,
      "numChannels": 1,
      "rtcpFeedback": [
        {
          "type": "nack",
          "parameter": ""
        },
        {
          "type": "nack",
          "parameter": "pli"
        },
        {
          "type": "goog-remb",
          "parameter": ""
        }
      ],
      "parameters": {
        "max-fr": "30",
        "max-fs": "3600"
      },
      "options": {},
      "maxTemporalLayers": 0,
      "maxSpatialLayers": 0,
      "svcMultiStreamSupport": false
    },
    {
      "name": "rtx",
      "kind": "video",
      "clockRate": 90000,
      "preferredPayloadType": 99,
      "maxptime": 0,
      "ptime": 0,
      "numChannels": 1,
      "rtcpFeedback": [],
      "parameters": {
        "apt": "107"
      },
      "options": {},
      "maxTemporalLayers": 0,
      "maxSpatialLayers": 0,
      "svcMultiStreamSupport": false
    },
    {
      "name": "rtx",
      "kind": "video",
      "clockRate": 90000,
      "preferredPayloadType": 96,
      "maxptime": 0,
      "ptime": 0,
      "numChannels": 1,
      "rtcpFeedback": [],
      "parameters": {
        "apt": "100"
      },
      "options": {},
      "maxTemporalLayers": 0,
      "maxSpatialLayers": 0,
      "svcMultiStreamSupport": false
    }
  ],
  "headerExtensions": [
    {
      "kind": "video",
      "uri": "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
      "preferredId": 1,
      "preferredEncrypt": false
    },
    {
      "kind": "video",
      "uri": "http://skype.com/experiments/rtp-hdrext/fast_bandwidth_feedback#version_2",
      "preferredId": 3,
      "preferredEncrypt": false
    }
  ],
  "fecMechanisms": []
}
    </pre>
         </section> 
                    </section>
                    <section id="red-codec-capability*">
                        <h3>RED</h3>
                        <p>As defined in [[!RFC2198]] Section 5, "red" has no codec-specific capability parameters.</p>
                        <p>The following setting is defined for "red", as noted in [[!RFC2198]] Section 5:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="sec-payloadtypes*">
                                    <td>payloadTypes</td>
                                    <td>
                                        <code>sequence&lt;payloadtype&gt</code>
                                    </td>
                                    <td>Sender/Receiver</td>
                                    <td>A sequence of payload types to be encapsulated in RED.</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="ulpfec-codec-capability*">
                        <h3>Ulpfec</h3>
                        <p>As noted in [[RFC5109]], "ulpfec" has no codec-specific capability parameters or settings.</p>
                    </section>
  </section>
</section>
  <section id="rtcrtpparameters*">
    <h3><dfn>RTCRtpParameters</dfn> Dictionary</h3>
    <p><code>RTCRtpParameters</code> contains the RTP stack settings.</p>
    <dl title='dictionary RTCRtpParameters' class='idl'>
      <dt>DOMString muxId=""</dt>
      <dd><p>The <var>muxId</var> assigned to the RTP stream, if any, empty string if unset.
In an <code><a>RTCRtpReceiver</a></code> or <code><a>RTCRtpSender</a></code> object, this corresponds to
<a>MID</a> RTP header extension defined in [[!BUNDLE]].
This is a stable identifier that permits the track corresponding to an RTP stream to be identified, rather than relying on an SSRC.
An SSRC is randomly generated and can change arbitrarily due to conflicts with other SSRCs, whereas
the <var>muxId</var> has a value
whose meaning can be defined in advance between RTP
sender and receiver, assisting in RTP demultiplexing.
Note that including <var>muxId</var> in <code><a>RTCRtpParameters</a></code> rather than in <code><a>RTCRtpEncodingParameters</a></code> implies that if it is desired to send simulcast streams with different <var>muxId</var> values for each stream, then multiple
<code><a>RTCRtpSender</a></code> objects are needed.</p>
      <div class="note">
Edge Interop Note:  Microsoft Edge currently does not support the <var>muxId</var> attribute, or the <a>MID</a> RTP header extension.
      </div>
</dd>
      <dt>sequence&lt;RTCRtpCodecParameters> codecs</dt>
      <dd><p>The codecs to send or receive (could include RED [[RFC2198]], RTX [[!RFC4588]] and CN [[RFC3389]]).</p></dd>
      <dt>sequence&lt;RTCRtpHeaderExtensionParameters> headerExtensions</dt>
      <dd><p>Configured header extensions.</p></dd>
      <dt>sequence&lt;RTCRtpEncodingParameters> encodings</dt>
      <dd><p>The "encodings" or "layers" to be used for simulcast and Scalable Video Coding, both unsupported.</p></dd>
      <dt>RTCRtcpParameters rtcp</dt>
      <dd><p>Parameters to configure RTCP.<p></dd>
                    <dt>RTCDegradationPreference degradationPreference = "balanced"</dt>
                    <dd>
                        <p>
                            When bandwidth is constrained and the <code><a>RTCRtpSender</a></code> needs to choose between degrading
                            resolution or degrading framerate, <code>degradationPreference</code> indicates which is preferred.
                            <code>degradationPreference</code> is ignored in an <code><a>RTCRtpReceiver</a></code> object.
                        </p>
                    </dd>
    </dl>
  </section>
            <section id="rtcrtpheaderextension*">
            <h3><code>RTCRtpHeaderExtension</code> Dictionary</h3>
                <dl class="idl" title="dictionary RTCRtpHeaderExtension">
                    <dt>DOMString kind</dt>
                    <dd>
                        <p>
                            The media supported by the header extension: "audio" for an audio codec,
                            "video" for a video codec, and "" for both.
                        </p>
                    </dd>
                    <dt>DOMString uri</dt>
                    <dd>
                        <p>The URI of the RTP header extension, as defined in [[!RFC5285]].</p>
                    </dd>
                    <dt>unsigned short preferredId</dt>
                    <dd>
                        <p>The preferred ID value that goes in the packet.</p>
                    </dd>
                    <dt>boolean preferredEncrypt=false</dt>
                    <dd>
                        <p>
                            If true, it is preferred that the value in the header be
                            encrypted as per [[!RFC6904]]. Default is to prefer unencrypted.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtpheaderextensionparameters*">
            <h3><dfn>RTCRtpHeaderExtensionParameters</dfn> Dictionary</h3>
                <dl class="idl" title="dictionary RTCRtpHeaderExtensionParameters">
                    <dt>DOMString uri</dt>
                    <dd>
                        <p>The URI of the RTP header extension, as defined in [[!RFC5285]].</p>
                    </dd>
                    <dt>unsigned short id</dt>
                    <dd>
                        <p>The value that goes in the packet.</p>
                    </dd>
                    <dt>boolean encrypt=false</dt>
                    <dd>
                        <p>If true, the value in the header is encrypted as per [[!RFC6904]]. Default is unencrypted.</p>
                    </dd>
                </dl>
            </section>
            <section id="headerextensions*">
                <h3>RTP header extensions</h3>
                <p>Registered RTP header extensions are listed in [[!IANA-RTP-10]]. Header extensions to be supported in Edge ORTC include: 
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Header Extension</th>
                            <th>Reference</th>
                            <th>Attributes</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="def-abs-send-time*">
                            <td><dfn>Absolute Send Time</dfn></td>
                            <td>
                                [[ABS-SEND-TIME]],[[REMB]] Section 3
                            </td>
                            <td>None</td>
                            <td>
                                This extension enables the absolute send time to be conveyed.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

<section id="rtcdegradationpreference*">
<h3><dfn>RTCDegradationPreference</dfn> Enum</h3>
<p>
<code>RTCDegradationPreference</code> can be used to indicate the desired choice between degrading resolution
and degrading framerate when bandwidth is constrained.
</p>

<dl class="idl" title="enum RTCDegradationPreference">
<dt>maintain-framerate</dt>
<dd>
 <p>Degrade resolution in order to maintain framerate.</p>
</dd>
<dt>maintain-resolution</dt>
<dd>
 <p>Degrade framerate in order to maintain resolution.</p>
</dd>
<dt>balanced</dt>
<dd>
 <p>Degrade a balance of framerate and resolution.</p>
</dd>
</dl>
</section>

<section id="rtcrtcpparameters*">
<h3><dfn>RTCRtcpParameters</dfn> Dictionary</h3>
<p><code>RTCRtcpParameters</code> provides information on RTCP settings.
<div class="note">
<p>Edge Interop Note:  Microsoft Edge currently does not support the <var>cname</var> attribute, and utilizes the <var>compound</var> attribute instead of the
<var>reducedSize</var> attribute (a boolean with the opposite meaning).  Also, Microsoft Edge requires that the <var>ssrc</var>
attribute be set even when <code><a>RTCRtpSender</a></code> object(s) exists from which SSRC information could be obtained.  In Microsoft Edge, the <var>ssrc</var>
attribute is used not only to fill in fields within RTCP packets that are sent, but also in order to route incoming RTCP packets (see Section 10.4). 
This is necessary since Microsoft Edge utilizes RTCP APP packets that do not contain the SSRC fields supported by all other RTCP packets, allowing those packets to
be routed to the relevant objects for processing.
Also note that Microsoft Edge Receiver Report (RR) packets contain extensions documented in [[!MS-RTP]]:
the RTCP Profile Specific Extension for Estimated Bandwidth (extension type 0x1, documented in [[!MS-RTP]] Section 2.2.11.1) and the
RTCP Profile Specific Extension for Network Congestion Notification (extension type 0xd, documented in [[!MS-RTP]] Section 2.2.11.11).
</p>
</div>

</p>
<dl title='dictionary RTCRtcpParameters' class='idl'>
<dt>unsigned long ssrc</dt>
<dd><p>For an <code><a>RTCRtpReceiver</a></code> this represents the SSRC to be used in the
"SSRC of packet sender" field defined in [[!RFC3550]] Section 6.4.2 (Receiver Report)
and [[!RFC4585]] Section 6.1 (Feedback Messages), as well as the "SSRC" field defined in [[!RFC3611]] Section 2 (Extended Reports).
For an <code><a>RTCRtpSender</a></code>, this represents the value to match against the "SSRC of packet sender" field in
order to route RTCP packets intended for that object (such as REMB and Receiver Reports).    
If unset, <var>ssrc</var> is chosen by the browser, and the chosen value is not reflected in <code>RTCRtcpParameters.ssrc</code>.
If the browser chooses the <var>ssrc</var> it may change it in event of a collision, as described in [[!RFC3550]].</p></dd>
<dt>DOMString cname</dt>
<dd><p>The Canonical Name (CNAME) used by RTCP (e.g. in SDES messages).  Guidelines for CNAME generation are provided in [[!RTP-USAGE]] Section 4.9 and [[!RFC7022]].
By default, ORTC implementations SHOULD set the CNAME to be the same within all <code>RTCRtcpParameter</code> objects created within the 
same Javascript sandbox.   For backward compatibility with WebRTC 1.0, applications MAY set <var>cname</var>; 
if unset, <var>cname</var> is chosen by the browser.  
</p></dd>
<dt>boolean compound=true</dt>
<dd><p>Whether reduced size RTCP [[!RFC5506]] is configured (if set to <code>false</code>) 
or compound RTCP as specified in [[!RFC3550]] (if set to <code>true</code>).  
The default is <code>true</code>.  
</p></dd>
<dt>boolean mux=true</dt>
<dd><p>Whether RTP and RTCP are multiplexed, as specified in [[!RFC5761]].
The default is <code>true</code>.  If set to <code>false</code>, the
<code><a>RTCIceTransport</a></code>
<em class="rfc2119" title="MUST">MUST</em> have an associated <code><a>RTCIceTransport</a></code> object with
a <var>component</var> of "RTCP",
in which case RTCP will be sent on the associated <code><a>RTCIceTransport</a></code>.
</p></dd>
</dl>
</section>

<section id="rtcrtpcodecparameters*">
<h3><dfn>RTCRtpCodecParameters</dfn> Dictionary</h3>
<p><code>RTCRtpCodecParameters</code> provides information on codec settings.</p>
<dl title='dictionary RTCRtpCodecParameters' class='idl'>
<dt>DOMString name</dt>
<dd><p>The MIME media type.  Valid types are
listed in [[!IANA-RTP-2]].  The <var>name</var> MUST always be provided.  
</p></dd>
<dt>payloadtype       payloadType</dt>
<dd><p>The value that goes in the RTP Payload Type Field [[!RFC3550]].  The <var>payloadType</var>
MUST always be provided.</p></dd>
<dt>unsigned long clockRate</dt>
<dd><p>Codec clock rate expressed in Hertz, null if unset.</p></dd>
<dt>unsigned long maxptime</dt>
<dd><p>The maximum packetization time set on the <code><a>RTCRtpSender</a></code>.
Not specified if unset. 
</p></dd>
<dt>unsigned long ptime</dt>
<dd>
<p>The duration of media represented by a packet in milliseconds for the <code><a>RTCRtpSender</a></code>.
If unset, the <code><a>RTCRtpSender</a></code> may select any value up to <var>maxptime</var>.
</dd>
<dt>unsigned long numChannels</dt>
<dd><p>The number of channels supported (e.g. stereo).  If unset for audio, use the codec default.  
For video, this can be left unset.</p></dd>
<dt>sequence&lt;RTCRtcpFeedback> rtcpFeedback</dt>
<dd><p>Transport layer and codec-specific feedback messages for this codec.</p></dd>
<dt>Dictionary parameters</dt>
<dd><p>Codec-specific parameters available for signaling.</p></dd>
</dl>

<section id="codec-parameters*">
<h3>Codec parameters</h3>

<p>The capabilities for commonly implemented codecs described in Section 9.4.2, are also
used as codec parameters, with
<code>RTCRtpCodecCapability.parameters</code> of the receiver used as
<code>RTCRtpCodecParameters.parameters</code> of the sender, and
<code>RTCRtpCodecCapability.parameters</code> of the sender used as
<code>RTCRtpCodecParameters.parameters</code> of the receiver, with the Property Name
and Values unchanged. 
</p>
</section>

</section>

<section id="rtcrtpencodingparameters*">
<h3><dfn>RTCRtpEncodingParameters</dfn> Dictionary</h3>
<dl class="idl" title="dictionary RTCRtpEncodingParameters">
<dt>unsigned long ssrc=null</dt>
<dd><p>The SSRC for this layering/encoding.
If <var>ssrc</var> is unset in a <code>RTCRtpEncodingParameters</code> object passed to the <code>RTCRtpReceiver.receive</code> method, 
then matching will occur based on payload type. 
If <var>ssrc</var> is unset in a <code>RTCRtpEncodingParameters</code> object passed to the <code>RTCRtpSender.send</code> 
method,  the browser will choose, and the chosen value is not reflected in <code>RTCRtpEncodingParameters.ssrc</code>.  
The Microsoft ORTC API implementation does not support detection or healing  SSRC collisions.  In the event that the 
browser chooses the <var>ssrc</var>, it will not change due to a collision. 
</p></dd>
<dt>payloadtype codecPayloadType</dt>
    <dd>
	<p>
	    For per-encoding codec specifications, give the codec Payload Type here.
	    If unset, the browser will choose.
	</p>
    </dd>
    <dt>RTCRtpFecParameters fec</dt>
    <dd>
	<p>Specifies the FEC mechanism if set.</p>
    </dd>
    <dt>RTCRtpRtxParameters rtx</dt>
    <dd>
	<p>Specifies the RTX [[!RFC4588]] parameters (such as the payload type to use for retransmitting this stream) if set.  
        The payload type to be retransmitted is specified in <var>codecPayloadType</var>.</p>
    </dd>
    <dt>double maxFramerate</dt>
    <dd>
        <p>The maximum framerate to use for this encoding. This setting is not used for scalable video coding.</p>
    </dd>
    <dt>boolean active=true</dt>
    <dd>
	<p>
	    For an <code><a>RTCRtpSender</a></code>, indicates whether this encoding is actively being sent.
	    Setting it to false causes this encoding to no longer be sent.
	    Setting it to true causes this encoding to be sent. If unset, the default (true) is assumed.
	    For an <code><a>RTCRtpReceiver</a></code>, indicates that this encoding is being decoded.
	    Setting it to false causes this encoding to no longer be decoded.
	    Setting it to true causes this encoding to be decoded. If unset, the default (true) is assumed.
	    Setting <var>active</var> to "false" is different than omitting the encoding, since
	    it can keep resources available to re-activate more quickly than re-adding the encoding.
	    As noted in [[RFC3264]] Section 5.1, RTCP is still sent, regardless of the value of the active attribute.
	</p>
    </dd>
</dl>
</section>
<section id="rtcrtpfecparameters*">
<h3><dfn>RTCRtpFecParameters</dfn> Dictionary</h3>
<dl title="dictionary RTCRtpFecParameters" class="idl">
    <dt>unsigned long ssrc</dt>
    <dd>
	<p>
	    The SSRC to use for FEC.
	    If unset in an <code><a>RTCRtpSender</a></code> object, the browser will choose.
	</p>
    </dd>
    <dt>DOMString mechanism</dt>
    <dd>
	<p>The Forward Error Correction (FEC) mechanism to use.</p>
    </dd>
</dl>
</section>
<section id="rtcrtprtxparameters*">
<h3><dfn>RTCRtpRtxParameters</dfn> Dictionary</h3>
<dl title="dictionary RTCRtpRtxParameters" class="idl">
    <dt>unsigned long ssrc</dt>
    <dd>
	<p>
	    The SSRC to use for retransmission, as specified in [[!RFC4588]].
	    If unset when passed to <code>RTCRtpSender.send()</code>, the browser will choose.
	</p>
</dl>
</section>
</section>

<section id="rtcdtmfsender*">
<h2><dfn>RTCDtmfSender</dfn> Interface</h2>

<section id="rtcdtmfsender-overview*">
<h3>Overview</h3>
<p>An <code>RTCDtmfSender</code> instance allows sending DTMF tones to/from the remote peer, as per [[!RFC4733]].</p>

</section>

<section id="rtcdtmfsender-operation*">
<h3>Operation</h3>

<p>An <a>RTCDtmfSender</a> object is constructed from an <a>RTCRtpSender</a> object.</p>
</section>

<section id="rtcdtmfsender-interface-definition*">
<h3>Interface Definition</h3>

<dl class="idl" title="[Constructor(RTCRtpSender sender)] interface RTCDtmfSender">
<dt>readonly attribute boolean <a>canInsertDTMF</a></dt>
<dd>
<p>Whether the <a>RTCDtmfSender</a> is capable of sending DTMF.</p>
</dd>

<dt>void insertDTMF(in DOMString tones, optional long duration, long
interToneGap)</dt>
<dd><p>The <code>insertDTMF()</code> method is used to send DTMF tones. 
Since DTMF tones cannot be sent without configuring the DTMF codec,
if <code>insertDTMF()</code> is called prior to <code>sender.send(parameters)</code>, or if
<code>sender.send(parameters)</code> was called but 
<var>parameters</var> did not include the DTMF codec,
throw an <code>InvalidStateError</code> exception.</p>
<p>The tones parameter is treated as a series of characters. The
characters 0 through 9, A through D, #, and * generate the associated
DTMF tones. The characters a to d are equivalent to A to D. The
character ',' indicates a delay of 2 seconds before processing the
next character in the tones parameter. All other characters <em title="MUST" class="rfc2119">MUST</em> be
considered <dfn id="dtmf-unrecognized">unrecognized</dfn>.</p>

<p>The duration parameter indicates the duration in ms to use for
each character passed in the tones parameters. The duration cannot be
more than 6000 ms or less than 40 ms. The default duration is 100 ms
for each tone.</p>

<p>The interToneGap parameter indicates the gap between tones. It
<em title="MUST" class="rfc2119">MUST</em> be at least 30 ms. The default value is 70 ms.</p>

<p>The browser <em title="MAY" class="rfc2119">MAY</em> increase the duration and interToneGap times to
cause the times that DTMF start and stop to align with the boundaries
of RTP packets but it <em title="MUST" class="rfc2119">MUST</em> not increase either of them by more than
the duration of a single RTP audio packet.</p>

<p>When the <code><a class="internalDFN" href="#dom-RTCDTMFSender-insertDTMF"><code>insertDTMF()</code></a></code> method is invoked, the
user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

<ol>
<li>Set the object's <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> attribute to
the value of the first argument, the <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> attribute to the
value of the second argument, and the <code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> attribute
to the value of the third argument.</li>

<li>If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> contains any
<a href="#dtmf-unrecognized">unrecognized</a> characters, throw an
<code>InvalidCharacterError</code> exception and abort these steps.
</li>

<li>If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> is an empty
string, return.</li>

<li>If the value of the <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> attribute is less
than 40, set it to 40. If, on the other hand, the value is greater
than 6000, set it to 6000.</li>

<li>If the value of the <code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> attribute
is less than 30, set it to 30.</li>

<li>If a <em>Playout task</em> is scheduled to be run; abort these
steps; otherwise queue a task that runs the following steps
(<em>Playout task</em>):

<ol>
<li>If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> is an
empty string, fire an event named <code><a href="#event-RTCDTMFSender-tonechange">tonechange</a></code> with an
empty string at the <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDtmfSender</code></a></code> object
and abort these steps.</li>

<li>Remove the first character from <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> and let
that character be <var>tone</var>.</li>

<li>Start playout of <var>tone</var> for <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> ms on the
associated RTP media stream, using the appropriate codec.</li>

<li>Queue a task to be executed in <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> +
<code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> ms
from now that runs the steps labelled <em>Playout
task</em>.</li>

<li>Fire an event named <code><a href="#event-RTCDTMFSender-tonechange">tonechange</a></code> with a
string consisting of <var>tone</var> at the
<code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDtmfSender</code></a></code> object.</li>
</ol>
</li>
</ol>

<p>Calling <code><a href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> with an empty
tones parameter can be used to cancel all tones queued to play after
the currently playing tone.</p>
</dd>

<dt>readonly attribute <a>RTCRtpSender</a> sender</dt>
<dd><p>The <a>RTCRtpSender</a> instance</p></dd>

<dt>attribute EventHandler ontonechange</dt>
<dd>
<p>The <dfn>ontonechange</dfn> event handler uses the
<a>RTCDTMFToneChangeEvent</a> interface to return the
character for each tone as it is played out. 
</p>
</dd>

<dt>readonly attribute DOMString toneBuffer</dt>
<dd>
<p>The <dfn>toneBuffer</dfn> attribute returns a list of the 
tones remaining to be played out.</p>
</dd> 

<dt>readonly attribute long duration</dt>

<dd>
<p>The <dfn>duration</dfn> attribute returns the current tone duration
value in milliseconds.  This value will be the value last set via the 
<code>insertDTMF()</code> method, or the default value of 100 ms if
<code>insertDTMF()</code> was called without specifying the duration.</p>
</dd>

<dt>readonly attribute long interToneGap</dt>

<dd>
<p>The <dfn>interToneGap</dfn> attribute returns the current value of
the between-tone gap.  This value will be the value last set via the
<code>insertDTMF()</code> method, or the default value of 70
ms if <code>insertDTMF()</code> was called without specifying
the <code>interToneGap.</code></p>
</dd>

</dl>

</section>

<section>
<h3>RTCDTMFToneChangeEvent</h3>

<p>The tonechange event uses the
<a>RTCDTMFToneChangeEvent</a> interface.</p>

<p>Firing an tonechange event named
<var>e</var> with a DOMString <var>tone</var> means
that an event with the name <var>e</var>, which does not bubble (except
where otherwise stated) and is not cancelable (except where otherwise
stated), and which uses the <a>RTCDTMFToneChangeEvent</a>
interface with the <a>tone</a>
attribute set to
<var>tone</var>, MUST be created and dispatched at the given target.</p>

<dl class="idl" data-merge="RTCDTMFToneChangeEventInit" title=
"[Constructor(DOMString type, RTCDTMFToneChangeEventInit eventInitDict)] interface RTCDTMFToneChangeEvent : Event">
<dt>readonly attribute DOMString tone</dt>
<dd>
<p>The <dfn>tone</dfn>
attribute contains the character for the tone that has just begun
playout (see <code>insertDTMF()</code>).  If the value is the
empty string, it indicates that the previous tone has completed
playback.</p>
</dd>
</dl>
<dl class="idl" title=
"dictionary RTCDTMFToneChangeEventInit : EventInit">
<dt>DOMString tone=""</dt>
<dd>
<p>The <a>tone</a> parameter is treated as a series of characters. 
The characters 0 through 9, A through D, #, and * generate the associated DTMF tones. 
The characters a to d are equivalent to A to D. 
The character ',' indicates a delay of 2 seconds before processing the next character in the tones parameter. 
Unrecognized characters are ignored.</p>
</dd>
</dl>
</section>
<section>
<h3>DTMF Example</h3>


<p>Examples assume that <var>sendObject</var> is an <code><a>RTCRtpSender</a></code> object.</p>

<p>Sending the DTMF signal "1234" with 500 ms duration per tone:</p>

<pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
if (sender.canInsertDTMF) {
var duration = 500;
sender.insertDTMF("1234", duration);
} else {
trace("DTMF function not available");
}      
</pre>

<p>Send the DTMF signal "1234", and light up the active key using
<code>lightKey(key)</code> while the tone is playing (assuming that
<code>lightKey("")</code> will darken all the keys):</p>

<pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function (e) {
if (!e.tone)
return;
// light up the key when playout starts
lightKey(e.tone);
// turn off the light after tone duration
setTimeout(lightKey, sender.duration, "");
};
sender.insertDTMF("1234");

</pre>

<p>Send a 1-second "1" tone followed by a 2-second "2" tone:</p>

<pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function (e) {
if (e.tone == "1")
sender.insertDTMF("2", 2000);
};
sender.insertDTMF("1", 1000);

</pre>

<p>It is always safe to append to the tone buffer. This example appends
before any tone playout has started as well as during playout.</p>

<pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
sender.insertDTMF("123");
// append more tones to the tone buffer before playout has begun
sender.insertDTMF(sender.toneBuffer + "456");

sender.ontonechange = function (e) {
if (e.tone == "1")
// append more tones when playout has begun
sender.insertDTMF(sender.toneBuffer + "789");
};

</pre>

<p>Send the DTMF signal "123" and abort after sending "2".</p>

<pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function (e) {
if (e.tone == "2")
// empty the buffer to not play any tone after "2"
sender.insertDTMF("");
};
sender.insertDTMF("123");

</pre>
</section>
</section>

<section>
<h3>Statistics API</h3>

<p>The Statistics API enables retrieval of statistics relating to <code><a>RTCRtpSender</a></code>, 
<code><a>RTCRtpReceiver</a></code>, 
<code><a>RTCDtlsTransport</a></code>, <code><a>RTCIceGatherer</a></code> and <code><a>RTCIceTransport</a></code> objects.
For detailed information on the Statistics API, consult [[!WEBRTC-STATS]]. 
</p>

<dl class="idl" title="interface RTCStatsProvider">
<dt>Promise&lt;RTCStatsReport> getStats()</dt>

<dd>
<p>Gathers stats for the given object
and reports the result asynchronously.
If the object has not yet begun to send or receive data, the returned
stats will reflect this.  If the object is in the closed state, the returned stats
will reflect the stats at the time the object transitioned to the closed state.  
</p>

<p>When the <dfn>getStats()</dfn> method is
invoked, the user agent MUST queue a task to run the following
steps:</p>

<ol>
<li>
<p>Let <var>p</var> be a new promise.</p>
</li>

<li>
<p>Return, but continue the following steps in the
background.</p>
</li>

<li>
<p>Start gathering the stats.</p>
</li>

<li>
<p>When the relevant stats have been gathered, return a 
new <code><a>RTCStatsReport</a></code> object, representing the
gathered stats.</p>
</li>
</ol>
</dd>
</dl>

<section>
<h4>RTCStatsReport Object</h4>

<p>The <code><a>getStats()</a></code>
method delivers a successful result in the form of a
<code><a>RTCStatsReport</a></code> object. A
<code><a>RTCStatsReport</a></code> object represents a map between
strings, identifying the inspected objects (<a href=
"#dom-rtcstats-id">RTCStats.id</a>), and their corresponding
<code><a>RTCStats</a></code> objects.</p>

<p>An <code><a>RTCStatsReport</a></code> may be composed of several
<code><a>RTCStats</a></code> objects, each reporting stats for one
underlying object.
One achieves the total for the object by summing over all stats of a 
certain type; for instance, if an <code><a>RTCRtpSender</a></code> object is sending
RTP streams involving multiple SSRCs over the network, the
<code><a>RTCStatsReport</a></code> may contain one <code>RTCStats</code>
object per SSRC (which can be distinguished by the value of the <var>ssrc</var>
stats attribute).</p>

<dl class="idl" title="interface RTCStatsReport">
<dt>getter RTCStats (DOMString id)</dt>
<dd>
<p>Getter to retrieve the <code><a>RTCStats</a></code> objects that
this stats report is composed of.</p>

<p>The set of supported property names [[!WEBIDL]] is defined as the
ids of all the <code><a>RTCStats</a></code> objects that has been
generated for this stats report. The order of the property names is
left to the user agent.</p>
</dd>
</dl>
</section>

<section>
<h4>RTCStats Dictionary</h4>
<p>An <code><a>RTCStats</a></code> dictionary represents the stats
gathered by inspecting a specific object.
The <code><a>RTCStats</a></code>
dictionary is a base type that specifies as set of default attributes,
such as <code>timestamp</code> and 
<code>type</code>. Specific stats are added by extending the
<code><a>RTCStats</a></code> dictionary.</p>

<p>Note that while stats names are standardized, any given implementation
may be using experimental values or values not yet known to the Web
application. Thus, applications MUST be prepared to deal with unknown
stats.</p>

<p>Statistics need to be synchronized with each other in order to yield
reasonable values in computation; for instance, if "bytesSent" and
"packetsSent" are both reported, they both need to be reported over the
same interval, so that "average packet size" can be computed as "bytes /
packets" - if the intervals are different, this will yield errors. Thus
implementations MUST return synchronized values for all stats in a
<code><a>RTCStats</a></code> object.</p>

<dl class="idl" title="dictionary RTCStats">
<dt>DOMHighResTimeStamp timestamp</dt>
<dd><p>The <dfn><code>timestamp</code></dfn>, of type <code>DOMHighResTimeStamp</code>
[[HIGHRES-TIME]], associated with this object. The time is relative
to the UNIX epoch (Jan 1, 1970, UTC). The timestamp for local
measurements corresponds to the to the local clock and for remote
measurements corresponds to the timestamp indicated in the incoming
RTCP Sender Report (SR), Receiver Report (RR) or Extended Report (XR).
</p></dd>
<dt>RTCStatsType type</dt>
<dd><p>The type of this object.</p>
<p>The <dfn id="dom-rtcstats-type"><code>type</code></dfn> attribute
<em class="rfc2119" title="MUST">MUST</em> be initialized to the name
of the most specific type this <code><a>RTCStats</a></code> dictionary
represents.</p></dd>
<dt> DOMString         id</dt>
<dd><p>A unique <code>id</code> that is associated with the object that
was inspected to produce this <code>RTCStats</code> object.
Two <code>RTCStats</code> objects, extracted from two different
<code>RTCStatsReport</code> objects,
<em class="rfc2119" title="MUST">MUST</em> have the same
<code>id</code> if they were produced by inspecting the same
underlying object. User agents are free to pick any format for the
<code>id</code> as long as it meets the requirements above.
</p></dd>
</dl>

<section id="rtcstatstype*">
<h3>RTCStatsType DOMString</h3>
<p><var>RTCStatsType</var> is equal to one of the following strings defined in [IANA-TOBE]:</p>
<dl>
<dt><code>"inboundrtp"</code></dt>
<dd><p>Statistics for the inbound RTP stream.  It is 
accessed via the <code>RTCInboundRTPStreamStats</code> defined
in [[!WEBRTC-STATS]] Section 4.2.3.  Local inbound RTP
statistics can be obtained from the <code><a>RTCRtpReceiver</a></code>
object; remote inbound RTP statistics can be obtained from the
<code><a>RTCRtpSender</a></code> object. 
</p></dd>

<dt><code>"outboundrtp"</code></dt>
<dd><p>Statistics for the outbound RTP stream.  It is 
accessed via the <code>RTCOutboundRTPStreamStats</code> defined in
[[!WEBRTC-STATS]] Section 4.2.4.  Local outbound RTP
statistics can be obtained from the <code><a>RTCRtpSender</a></code>
object; remote outbound RTP statistics can be obtained from the
<code><a>RTCRtpReceiver</a></code> object.
</p></dd>

<dt><code>"track"</code></dt>
<dd><p>Statistics relating to the <code>MediaStreamTrack</code> object.  
It is accessed via the <code>RTCMediaStreamTrackStats</code> defined in [[!WEBRTC-STATS]] Section 4.4.2. 
</p></dd>

<dt><code>"transport"</code></dt>
<dd><p>Transport statistics related to the <code><a>RTCDtlsTransport</a></code> object.
It is accessed via the <code>RTCTransportStats</code> and <code>RTCCertificateStats</code> 
defined in [[!WEBRTC-STATS]] Sections 4.6 and 4.9. 
</p></dd>

<dt><code>"candidatepair"</code></dt>
<dd><p>ICE candidate pair statistics related to 
<code><a>RTCIceTransport</a></code> objects.
It is accessed via the <code>RTCIceCandidatePairStats</code> defined in [[!WEBRTC-STATS]] Section 4.8. 
</p></dd>

<dt><code>"localcandidate"</code></dt>
<dd><p>ICE local candidates, related to
<code><a>RTCIceGatherer</a></code> objects.
It is accessed via the <code>RTCIceCandidateAttributes</code> defined in [[!WEBRTC-STATS]] Section 4.7. 
</p></dd>

<dt><code>"remotecandidate"</code></dt>
<dd><p>ICE remote candidate, related to
<code><a>RTCIceTransport</a></code> objects.
It is accessed via the <code>RTCIceCandidateAttributes</code> defined in [[!WEBRTC-STATS]] Section 4.7. 
</p></dd>
</dl>
</section>
</section>
<section id="rtcpmatchingrules*">
<h3>RTP/RTCP routing rules</h3>
<p>Edge implements a subset of the RTP routing rules described in [[!BUNDLE]] Section 10.2.      
Since Edge does not support the MID RTP header extension, it does not route RTP packets
based on the contents of that header extension, nor does it support the      
<code><a>RTCRtpParameters</a>.muxId</code> attribute.  However, Edge does
support RTP packet routing based on the Payload Type (PT) as well as SSRCs.
Since Edge does not support the RTCRtpListener
object, RTP packets that cannot be routed to an <code>RTCRtpReceiver</code> are
dropped.</p>
<p>Since statistics are retrieved from objects within the ORTC API, and information within RTCP packets
is used to maintain some of the statistics, the routing of RTCP packets is important to the operation
of the statistics API as well as to the operation of congestion control.</p>
<p>RTCP packets arriving on an <code><a>RTCDtlsTransport</a></code> are decrypted and a notification is sent to all
<code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects utilizing
that transport.
<code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects then
examine the RTCP packets to determine the information relevant to their operation and the statistics
maintained by them.</p>
<p>RTCP packets should be queued for 30 seconds and all <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> 
objects on the related <code><a>RTCDTlsTransport</a></code> have access to those packets until the packet is removed from the queue,
should the <code><a>RTCRtpSender</a></code> or <code><a>RTCRtpReceiver</a></code> objects need to examine them.</p>
<p>Relevant SSRC fields within selected RTCP packets are summarized 
within [[!RFC3550]] Section 6.4.1 (Sender Report),
Section 6.4.2 (Receiver Report), Section 6.5 (SDES),
Section 6.6 (BYE), [[!RFC4585]] Section 6.1 (Feedback Messages),
and [[!RFC3611]] Section 2 (Extended Reports).</p>
</section>
<section>
<h4>Example</h4>

<p>Consider the case where the user is experiencing bad sound and the application wants to 
determine if the cause of it is packet loss.  The following example code might be used:</p>

<pre class="example highlight" xml:space="preserve">
var mySender = new RTCRtpSender(myTrack); 
var myPreviousReport = null;

// ... wait a bit
setTimeout(function () {
mySender.getStats().then(function (report) {
processStats(report);
myPreviousReport = report;
});
}, aBit);

function processStats(currentReport) {
if (myPreviousReport === null) return;
// currentReport + myPreviousReport are an RTCStatsReport interface
// compare the elements from the current report with the baseline
for (var i in currentReport) {
var now = currentReport[i]; 
if (now.type != "outboundrtp")
continue;
// get the corresponding stats from the previous report
base = myPreviousReport[now.id];
// base + now will be of RTCRtpStreamStats dictionary type
if (base) {
remoteNow = currentReport[now.associateStatsId];
remoteBase = myPreviousReport[base.associateStatsId];
var packetsSent = now.packetsSent - base.packetsSent;
var packetsReceived = remoteNow.packetsReceived - remoteBase.packetsReceived;
// if fractionLost is > 0.3, we have probably found the culprit
var fractionLost = (packetsSent - packetsReceived) / packetsSent;
}
}
}
</pre>

</section>
</section>
</section>

<section id="msextensions*">
<h2>Microsoft-specific extensions</h2>

<section id="h264uc*">
<h3>H.264UC extensions</h3>

<p>The extensions defined in this section relate to Microsoft's implementation of the H.264/SVC codec 
("H.264UC"), documented in [[MS-H264PF]].</p>

<section id="sendcsrc*">

<h3>Send CSRC</h3>

<p>The <dfn>requestSendCSRC</dfn> method extends the <code><a>RTCRtpReceiver</a></code> object,
requesting that a source identified by a CSRC be sent to the receiver.  This extension is designed for
use with the H.264UC codec, which supports an RTCP source request message.</p>

<dl class="idl" title="partial interface RTCRtpReceiver">
<dt>void requestSendCSRC(unsigned long csrc)</dt>
<dd><p>Request that the source identified by <var>csrc</var> be sent to
the <code><a>RTCRtpReceiver</a></code> object.</p></dd>
</dl>

</section>

<section id="sourcerange*">

<h3>Source Range</h3>

<p>The <dfn>range</dfn> extension to <code>RTCRtpEncodingParameters</code> enables an
implementation of the H.264UC codec supporting <code><a>MRST</a></code> transport to demultiplex layers encoded
with a range of SSRCs.
</p>

<dl class="idl" title="partial dictionary RTCRtpEncodingParameters">
<dt>RTCSsrcRange ssrcRange</dt>
<dd><p>Associate a range of SSRC values with an <code><a>RTCRtpReceiver</a></code> or <code><a>RTCRtpSender</a></code>.
When present in <code><a>RTCRtpEncodingParameters</a></code> passed in a call to
to <code>RTCRtpReceiver.receive</code>, this extension tells an <code><a>RTCRtpReceiver</a></code>
object to demultiplex RTP packets sent by an H.264UC encoder with <code><a>MRST</a></code> transport,
utilizing a range of SSRCs.
When present in <code><a>RTCRtpEncodingParameters</a></code> passed in a call to
to <code>RTCRtpSender.send</code>, this extension instructs an <code><a>RTCRtpSender</a></code>
object utilizing an H.264UC encoder to send RTP packets with <code><a>MRST</a></code> transport, utilizing a
range of SSRCs.  [[MS-SDPEXT]] Section 3.1.5.31 describes extensions for synchronization source range allocation.
</dl>

<section id="ssrcrange*">
<h3>dictionary RTCSsrcRange</h3>
<dl title='dictionary RTCSsrcRange' class='idl'>
<dt>unsigned long min</dt>
<dd><p>Beginning of the SSRC range.</p></dd>
<dt>unsigned long max</dt>
<dd><p>End of the SSRC range.</p></dd>
</dl>
</section>
</section>
</section>

<section id="msstatsex*">
<h3>Microsoft statistics extensions</h3>

<p>The Microsoft statistics extensions enable retrieval of end-of-call statistics relating to <code><a>RTCRtpSender</a></code>,
<code><a>RTCRtpReceiver</a></code> and <code><a>RTCIceTransport</a></code> objects.</p>  

<div class="note">
<p>Due to the load placed on the browser, these statistics SHOULD NOT be continuously
retrieved and are intended for collection of information on objects in or soon to be entering the
"closed" state.
</p>
</div>

<dl class="idl" title="partial interface RTCStatsProvider">
<dt>Promise&lt;RTCStatsReport> msGetStats()</dt>

<dd>
<p>Gathers stats for the given object and reports the result asynchronously.
If the object has not yet begun to send or receive data, the returned
stats will reflect this.  If the object is in the closed state, the returned stats
will reflect the stats at the time the object transitioned to the closed state.
</p>

<p>When the <dfn>msGetStats()</dfn> method is
invoked, the user agent MUST queue a task to run the following
steps:</p>

<ol>
<li>
<p>Let <var>p</var> be a new promise.</p>
</li>

<li>
<p>Return, but continue the following steps in the
background.</p>
</li>

<li>
<p>Start gathering the stats.</p>
</li>

<li>
<p>When the relevant stats have been gathered, return a
new <code><a>RTCStatsReport</a></code> object, representing the
gathered stats.</p>
</li>
</ol>
</dd>
</dl>

<section>
<h4>RTCStats Dictionary extension</h4>
<p>The Microsoft statistics extension extends the <code><a>RTCStats</a></code> dictionary
to support new statistics types.

<dl class="idl" title="partial dictionary RTCStats">
<dt>MSStatsType msType</dt>
<dd><p>The type of this object.</p>
<p>The msType attribute
<em class="rfc2119" title="MUST">MUST</em> be initialized to the name
of the most specific type this <code><a>RTCStats</a></code> dictionary
represents.</p></dd>
</dl>

<section id="msstatstype*">
<h3>MSStatsType DOMString</h3>
<p><var>MSStatsType</var> is equal to one of the following strings:</p>
<dl>
<dt><code>"description"</code></dt>
<dd><p>Descriptive information relating to
<code><a>RTCRtpReceiver</a></code> and <code><a>RTCRtpSender</a></code> objects.
It is accessed via the <code><a>MSDescription</a></code> object.  Local descriptive information can obtained from the
<code><a>RTCRtpReceiver</a></code> and <code><a>RTCRtpSender</a></code> objects.
Remote descriptive information is not supported.
</p></dd>

<dt><code>"localclientevent"</code></dt>
<dd><p>Local client events, relating to
<code><a>RTCRtpReceiver</a></code> and <code><a>RTCRtpSender</a></code> objects.
It is accessed via the <code><a>MSLocalClientEvent</a></code> object.  Local client events can obtained from the
<code><a>RTCRtpReceiver</a></code> and <code><a>RTCRtpSender</a></code> objects.
Remote client events are not supported.
</p></dd>

<dt><code>"inbound-network"</code></dt>
<dd><p>Inbound network statistics.  It is
accessed via the <code><a>MSNetwork</a></code> object.  Local inbound statistics can be obtained
from the <code><a>RTCRtpReceiver</a></code> object.
Remote inbound network statistics are not supported. 
</p></dd>

<dt><code>"outbound-network"</code></dt>
<dd><p>Outbound network statistics.  It is
accessed via the <code><a>MSOutboundNetwork</a></code> object.  Local outbound statistics can be obtained
from the <code><a>RTCRtpSender</a></code>
object.  Remote outbound network statistics are not supported. 
</p></dd>
<dt><code>"inbound-payload"</code></dt>
<dd><p>Statistics for the inbound RTP stream.  It is
accessed via <code><a>MSVideoRecvPayload</a></code> and <code><a>MSAudioRecvPayload</a></code> objects.  
Local inbound statistics can be obtained
from the <code><a>RTCRtpReceiver</a></code> object. 
Remote inbound RTP statistics are not supported. 
</p></dd>

<dt><code>"outbound-payload"</code></dt>
<dd><p>Statistics for the outbound RTP stream.  It is
accessed via <code><a>MSVideoSendPayload</a></code> and <code><a>MSAudioSendPayload</a></code> objects.  
Local inbound statistics can be obtained
from the <code><a>RTCRtpSender</a></code>
object.  Remote outbound RTP statistics are not supported. 
</p></dd>

<dt><code>"transportdiagnostics"</code></dt>
<dd><p>Transport diagostics related to the <code><a>RTCIceTransport</a></code> object.
It is accessed via the <code><a>MSTransportDiagnosticsStats</a></code> object.  Local transport diagnostics can be obtained fron the
<code><a>RTCIceTransport</a></code> object. 
Remote transport diagnostics are not supported.  
</p></dd>
</dl>
</section>
</section>

<section id="msicetype*">
<h3>Enum MSIceType</h3>
<p><dfn>MSIceType</dfn> contains information about the media path. 
It is described in [[MS-QoE]] Section 2.2.1.7 (Ice). 
</p>
<dl class="idl" title="enum MSIceType">
<dt>failed</dt>
<dd><p>This indicates that the local ICE state machine has failed to find a successful candidate pair.</p></dd>

<dt>direct</dt>
<dd><p>This indicates that the local candidate within the selected candidate pair is a host candidate.</p></dd>

<dt>relay</dt>
<dd><p>This indicates that the local candidate within the selected candidate pair is a relay candidate..</p></dd>
</dl>
</section>

<section id="msicewarningflags*">
<h3>Dictionary MSIceWarningFlags</h3>
<p><dfn>MSIceWarningFlags</dfn> contains information about the ICE process described in bit flags.  It is defined in [[MS-QoE]] Section 2.2.1.7.1, (IceWarningFlags), relating to footnote 57.
</p>

<dl class="idl" title="dictionary MSIceWarningFlags">
<dt>boolean turnTcpTimedOut</dt>
<dd><p>TURN server is unreachable.</p></dd>
<dt>boolean turnUdpAllocateFailed</dt>
<dd><p>An attempt to allocate a UDP port on the TURN server failed.</p></dd>
<dt>boolean turnUdpSendFailed</dt>
<dd><p>An attempt to send UDP on the TURN server failed.</p></dd>
<dt>boolean turnTcpAllocateFailed</dt>
<dd><p>An attempt to allocate a Transmission Control Protocol (TCP) port on the TURN server failed.</p></dd>
<dt>boolean turnTcpSendFailed</dt>
<dd><p>An attempt to send TCP on the TURN server failed.</p></dd>
<dt>boolean udpLocalConnectivityFailed</dt>
<dd><p>UDP local connectivity failed.</p></dd>
<dt>boolean udpNatConnectivityFailed</dt>
<dd><p>UDP NAT connectivity failed.</p></dd>
<dt>boolean udpRelayConnectivityFailed</dt>
<dd><p>UDP TURN server connectivity failed.</p></dd>
<dt>boolean tcpNatConnectivityFailed</dt>
<dd><p>TCP NAT connectivity failed.</p></dd>
<dt>boolean tcpRelayConnectivityFailed</dt>
<dd><p>TCP TURN server connectivity failed.</p></dd>
<dt>boolean connCheckMessageIntegrityFailed</dt>
<dd><p>Message integrity failed in connectivity check request.</p></dd>
<dt>boolean allocationMessageIntegrityFailed</dt>
<dd><p>The message integrity on the response message was incorrect.</p></dd>
<dt>boolean connCheckOtherError</dt>
<dd><p>Connectivity check request failed because of memory problem or other reasons that prevent sending packets.</p></dd>
<dt>boolean turnAuthUnknownUsernameError</dt>
<dd><p>TURN Server credentials expired or are unknown.</p></dd>
<dt>boolean noRelayServersConfigured</dt>
<dd><p>No TURN server configured.</p></dd>
<dt>boolean multipleRelayServersAttempted</dt>
<dd><p>Multiple TURN servers were attempted for the allocation.</p></dd>
<dt>boolean portRangeExhausted</dt>
<dd><p>Port range exhausted.</p></dd>
<dt>boolean alternateServerReceived</dt>
<dd><p>Received alternate TURN server.</p></dd>
<dt>boolean pseudoTLSFailure</dt>
<dd><p>Pseudo-TLS failure.  See [[MS-TURN]] Section 2.1.1.</p></dd>
<dt>boolean turnTurnTcpConnectivityFailed</dt>
<dd><p>TCP-TCP connectivity checks failed over TURN Server.</p></dd>
<dt>boolean useCandidateChecksFailed</dt>
<dd><p>Use candidates check failed.</p></dd>
<dt>boolean fipsAllocationFailure</dt>
<dd><p>Allocation failure due to enforcement of FIPS policy (e.g. SHA-1 not allowed).</p></dd>
</dl>
</section>

<section id="msrelayaddress*">
<h3>Dictionary MSRelayAddress</h3>
<p><dfn>MSRelayAddress</dfn> contains IP address related information of the relay server.  It is described in [[MS-QoE]] Section 2.2.1.7.1 (RelayAddress). 
</p>

<dl class="idl" title="dictionary MSRelayAddress">
<dt>DOMString relayAddress</dt>
<dd><p>The IP address of the relay.</p></dd>
<dt>unsigned short port</dt>
<dd><p>The port of the relay.</p></dd>
</dl>
</section>

<section id="msconnectivity*">
<h3>Dictionary MSConnectivity</h3>
<p><dfn>MSConnectivity</dfn> contains ICE connectivity information. It is described in [[MS-QoE]] Section 2.2.1.7 (Connectivity).
</p>

<dl class="idl" title="dictionary MSConnectivity">
<dt>MSIceType iceType</dt>
<dd><p>Information about the media path.</p></dd>
<dt>MSIceWarningFlags iceWarningFlags</dt>
<dd><p>Information about ICE process described in bitflags.</p></dd>
<dt>MSRelayAddress relayAddress</dt>
<dd><p>IP address related information of the relay.</p></dd>
</dl>
</section>

<section id="msnetworkconnectivityinfo*">
<h3>Dictionary MSNetworkConnectivityInfo</h3>
<p><dfn>MSNetworkConnectivityInfo</dfn> contains information specific to the network connection.  It is described in [[MS-QoE]] Section 2.2.1.8 (NetworkConnectivityInfo).
</p>

<dl class="idl" title="dictionary MSNetworkConnectivityInfo">
<dt>boolean vpn</dt>
<dd><p>"True" if user is on VPN, "False" if not.</p></dd>
<dt>unsigned long long linkspeed</dt>
<dd><p>The link speed of the network interface of the endpoint, in bits per second.</p></dd> 
<dt>DOMString networkConnectionDetails</dt>
<dd><p>Information about the interface type.  Valid types include "Other" (an interface type other than Ethernet, WiFi, PPP, Tunnnel or Mobile BB), 
"Ethernet" (an interface identified as Ethernet by the operating system), "WiFi" (an IEEE 802.11 interface), "PPP" (a PPP interface, such as dialup, PPPoE or VPN), 
"Tunnel" (a tunnel interface such as a GRE or IPv6 tunnel), or "MobileBB" (a mobile broadband interface such as LTE).
ISSUE: are the strings spelled correctly? Is an L2TP or PPTP VPN classified as a PPP or Tunnel interface?</p></dd>
<dt>unsigned long wifiChannel</dt>
<dd><p>Wifi channel used during the call.</p></dd>
<dt>unsigned long wifiHandovers</dt>
<dd><p>Number of handovers during the call.</p></dd>
<dt>unsigned long wifiSignalStrength</dt>
<dd><p>Wifi signal strength in RSSI.</p></dd>
<dt>unsigned long wifiChannelSwitches</dt>
<dd><p>Number of channel switches during the call.</p></dd>
<dt>unsigned long long wifiReceiverRate</dt>
<dd><p>Wifi receive rate, in bits/second.</p></dd>
<dt>unsigned long long wifiSendRate</dt>
<dd><p>Wifi send rate, in bits/second.</p></dd>
</dl>
</section>

<section id="msipaddressinfo*">
<h3>Dictionary MSIPAddressInfo</h3>
<p><dfn>MSIPAddressInfo</dfn> contains information on the endpoint addresses.  It is defined in [[MS-QoE]] Section 2.2.1.9 (AddrType).
</p>

<dl class="idl" title="dictionary MSIPAddressInfo">
<dt>DOMString ipAddr</dt>
<dd><p>The IP listening address for the stream in appropriate notation (IPv4 or IPv6).</p></dd>
<dt>unsigned short port</dt>
<dd><p>The listening port for the stream.</p></dd>
<dt>DOMString manufacturerMacAddrMask = ""</dt>
<dd><p>The OUI portion of the media access control address address of the network interface adapter associated with the IPAddr.</p></dd>
</dl>
</section>

<section id="msdescription*">
<h3>Dictionary MSDescription</h3>
<p><dfn>MSDescription</dfn> contains basic information relating to the endpoint.
</p>

<dl class="idl" title="dictionary MSDescription">
<dt>MSConnectivity connectivity</dt>
<dd><p>ICE connectivity information.</p></dd>
<dt>RTCIceProtocol transport</dt>
<dd><p>Information on ICE candidate transport.</p></dd>
<dt>MSNetworkConnectivityInfo networkconnectivity</dt>
<dd><p>Information specific to the network connection.</p></dd>
<dt>MSIPAddressInfo localAddr</dt>
<dd><p>Internet Protocol (IP) address related information for the reporting endpoint, described in [[MS-QoE]] Section 2.2.1.6.1 (LocalAddr).</p></dd>
<dt>MSIPAddressInfo remoteAddr</dt>
<dd><p>IP address related information related for the remote endpoint, described in [[MS-QoE]] Section 2.2.1.6.1 (RemoteAddr).</p></dd>
<dt>DOMString deviceDevName = ""</dt>
<dd><p>This represents the "CaptureDev" (for an <code>RtpReceiver</code>) or a "RenderDev" (for an <code>RtpSender</code>), as described in [[MS-QoE]] Section 2.2.1.6.1.</p></dd>
<dt>MSIPAddressInfo reflexiveLocalIPAddr</dt>
<dd><p>The IP address from which the Media Relay received the allocate request, described in [[MS-QoE]] Section 2.2.1.6.1 (ReflexiveLocalIPAddress).  This address is returned by the Media Relay.</p></dd>
</dl>
</section>

<section id="mslocalclienteventbase*">
<h3>Dictionary MSLocalClientEventBase</h3>
<p><dfn>MSLocalClientEventBase</dfn> contains information about the quality events detected by the endpoint.  It is described in [[MS-QoE]] Section 2.2.1.29.
</p>

<dl class="idl" title="typedef (MSLocalClientEventBase or MSAudioLocalClientEvent) MSLocalClientEvent">
</dl>

<dl class="idl" title="dictionary MSLocalClientEventBase">
<dt>float networkReceiveQualityEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected the network was causing poor quality of the audio received.</p></dd>
<dt>float networkBandwidthLowEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected the available
bandwidth or bandwidth policy was low enough to cause poor quality of the audio sent.</p></dd>
</dl>
</section>

<section id="msaudiolocalclientevent*">
<h3>Dictionary MSAudioLocalClientEvent</h3>
<p><dfn>MSAudioLocalClientEvent</dfn> contains information about the quality events detected by the endpoint.  It is described in [[MS-QoE]] Section 2.2.1.29. 
</p>

<dl class="idl" title="dictionary MSAudioLocalClientEvent : MSLocalClientEventBase">
<dt>float networkSendQualityEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detecteed the network was causing poor quality of the audio sent.</p></dd>
<dt>float networkDelayEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected the network delay was significant enough to impact the ability to have real-time two-way communication.</p></dd>
<dt>float deviceHalfDuplexAECEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected issues and operated the acoustic echo canceller in half-duplex mode, which impacted the ability to have real-time two-way communication.</p></dd>
<dt>float deviceRenderNotFunctioningEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected the render device was not working properly.</p></dd>
<dt>float deviceCaptureNotFunctioningEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected the capture device was not working properly.</p></dd>
<dt>float deviceGlitchesEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected glitches or gaps in the audio played or captured that caused poor quality of the audio being sent or received.</p></dd>
<dt>float deviceLowSNREventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected low speech to noise level that caused poor quality of the audio being sent.</p></dd>
<dt>float deviceLowSpeechLevelEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected low speech level that caused poor qualitiy of the audio being sent.</p></dd>
<dt>float deviceClippingEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected clipping in the captured audio that caused poor quality of the audio being sent.</p></dd>
<dt>float deviceEchoEventRatio</dt>
<dd><p>Fraction of the call that the reporting endpoint detected echo that caused poor quality of the audio being sent.</p></dd>
<dt>float deviceRenderZeroVolumeEventRatio</dt>
<dd><p>Fraction of the call that device render volume is set to 0.</p></dd>
<dt>float deviceRenderMuteEventRatio</dt>
<dd><p>Fraction of the call that device render is muted.</p></dd>
<dt>unsigned long deviceMultipleEndpointsEventCount</dt>
<dd><p>Number of times during the call that the reporting endpoint detected mutliple endpoints in the same room or acoustic environment.</p></dd>
<dt>unsigned long deviceHowlingEventCount</dt>
<dd><p>Number of times during the call that the reporting endpoint detected two or more endpoints in the same room or acoustic environment that caused poor quality audio in the form of howling or screeching audio.</p></dd>
</dl>
</section>


<section id="msjitter*">
<h3>Dictionary MSJitter</h3>
<p><dfn>MSJitter</dfn> contains metrics related to jitter.  It is described in [[MS-QoE]] Section 2.2.1.27 (Jitter).
</p>

<dl class="idl" title="dictionary MSJitter">
<dt>unsigned long interArrival</dt>
<dd><p>The average inter-arrival jitter, as specified in [[!RFC3550]] Section 6.4.1, in ms.</p></dd>
<dt>unsigned long interArrivalMax</dt>
<dd><p>The maximum inter-arrival jitter, as specified in [[!RFC3550]] Section 6.4.1, in ms.</p></dd>
<dt>float interArrivalSD</dt>
<dd><p>The standard deviation of inter-arrival jitter, as specified in [[!RFC3550]] Section 6.4.1, in ms.</p></dd>
</dl>
</section>

<section id="msdelay*">
<h3>Dictionary MSDelay</h3>
<p><dfn>MSDelay</dfn> contains metrics related to delays.  It is described in [[MS-QoE]] Section 2.2.1.26 (Delay).
</p>

<dl class="idl" title="dictionary MSDelay">
<dt>unsigned long roundTrip</dt>
<dd><p>The average network propagation round-trip time computed as specified in [[!RFC3550]] Section 6.4.1, in ms.</p></dd>
<dt>unsigned long roundTripMax</dt>
<dd><p>The maximum network propagation round-trip time computed as specified in [[!RFC3550]] Section 6.4.1, in ms.</p></dd>
</dl>
</section>

<section id="mspacketloss*">
<h3>Dictionary MSPacketLoss</h3>
<p><dfn>MSPacketLoss</dfn> contains metrics related to packet loss.   It is described in [[MS-QoE]] Section 2.2.1.24 (PacketLoss).
</p>

<dl class="idl" title="dictionary MSPacketLoss">
<dt>float lossRate</dt>
<dd><p>The average fraction lost, as specified in [[!RFC3550]] Section 6.4.1, computed over the duration of the session.</p></dd>
<dt>float lossRateMax</dt>
<dd><p>The maximum fraction lost, as specified in [[!RFC3550]] Section 6.4.1, computed over the duration of the session.</p></dd>
</dl>
</section>

<section id="msutilization*">
<h3>Dictionary MSUtilization</h3>
<p><dfn>MSUtilization</dfn> contains metrics related to network utilization.  It is described in [[MS-QoE]] Section 2.2.1.23 (Utilization).
</p>

<dl class="idl" title="dictionary MSUtilization">
<dt>unsigned long packets</dt>
<dd><p>Number of Real-Time Transport Protocol (RTP) packets sent in the session.</p></dd>
<dt>unsigned long bandwidthEstimation</dt>
<dd><p>Estimated one way available bandwidth of the stream at the end of the session in bits/second.</p></dd>
<dt>unsigned long bandwidthEstimationMin</dt>
<dd><p>Minimal estimated one way available bandwidth of the stream at the end of the session in bits/second.</p></dd>
<dt>unsigned long bandwidthEstimationMax</dt>
<dd><p>Maximum estimated one way available bandwidth of the stream at the end of the session.</p></dd>
<dt>unsigned long bandwidthEstimationStdDev</dt>
<dd><p>Standard deviation of estimated one way available bandwidth of the stream at the end of the session.</p></dd>
<dt>unsigned long bandwidthEstimationAvg</dt>
<dd><p>Average estimated one way available bandwidth of the stream at the end of the session.</p></dd>
</dl>
</section>
	
<section id="msinboundtimeout*">
<h3>Dictionary MSInboundTimeout</h3>
<p><dfn>MSInboundTimeout</dfn> contains metrics related to inbound timeouts.</p>

<dl class="idl" title="dictionary MSInboundTimeout">
<dt>boolean mediaTimeout</dt>
<dd><p>Set to <code>true</code> if a media timeout is detected.</p></dd>
<dt>unsigned long long errTime</dt>
<dd><p>Time at which the channel blob sends or receives an error, measured
relative to the reference time (midnight UTC (00:00) on January 1, 1900) in ms.</p></dd>
<dt>unsigned long long rtcpTime</dt>
<dd><p>Time at which the last RTCP packet was received, measured
relative to the reference time (midnight UTC (00:00) on January 1, 1900) in ms.</p></dd>
<dt>unsigned long long rtpTime</dt>
<dd><p>Time at which the last RTP packet was received, measured
relative to the reference time (midnight UTC (00:00) on January 1, 1900) in ms.</p></dd>
<dt>MSNetworkInterfaceType interfacesStall</dt>
<dd><p>Interface types available when the media timeout occurred.</p></dd>
<dt>unsigned long transportRecvError</dt>
<dd><p>Last socket error observed while attempting to receive.</p></dd>
</dl>
</section>

<section id="msoutboundtimeout*">
<h3>Dictionary MSOutboundTimeout</h3>
<p><dfn>MSOutboundTimeout</dfn> contains metrics related to outbound timeouts.</p>

<dl class="idl" title="dictionary MSOutboundTimeout">
<dt>boolean mediaTimeout</dt>
<dd><p>Set to <code>true</code> if a media timeout is detected.</p></dd>
<dt>unsigned long long errTime</dt>
<dd><p>Time at which the channel blob sends or receives an error, measured
relative to the reference time (midnight UTC (00:00) on January 1, 1900) in ms.</p></dd>
<dt>unsigned long long rtcpTime</dt>
<dd><p>Time at which the last RTCP packet was received, measured
relative to the reference time (midnight UTC (00:00) on January 1, 1900) in ms.</p></dd>
<dt>MSNetworkInterfaceType interfacesStall</dt>
<dd><p>Interface types available when the media timeout occurred.</p></dd>
<dt>unsigned long transportSendError</dt>
<dd><p>Last socket error observed while attempting to send.</p></dd>
</dl>
</section>

<section id="msnetwork*">
<h3>Dictionary MSNetwork</h3>
<p><dfn>MSNetwork</dfn> contains network-based metrics.  It is described in [[MS-QoE]] Section 2.2.1.12 (Network).
</p>

<dl class="idl" title="dictionary MSNetwork">
<dt>MSJitter jitter</dt>
<dd><p>Jitter-related metrics.</p></dd>
<dt>MSDelay delay</dt>
<dd><p>Delay-related metrics.</p></dd>
<dt>MSPacketLoss packetLoss</dt>
<dd><p>Packet loss related metrics.</p></dd>
<dt>MSUtilization utilization</dt>
<dd><p>Utilization related metrics.</p></dd>
</dl>
</section>
	
<section id="msinboundnetwork*">
<h3>Dictionary MSInboundNetwork</h3>
<p><dfn>MSInboundNetwork</dfn> contains additonal information relating to timeouts,
in addition to the information provided in the <code><a>MSNetwork</a></code> base class.</p>
	
<dl class="idl" title="dictionary MSInboundNetwork : MSNetwork">
<dt>MSInboundTimeout timeout</dt>
<dd><p>Metrics relating to timeouts.</p></dd>
</dl>
</section>

<section id="msoutboundnetwork*">
<h3>Dictionary MSOutboundNetwork</h3>
<p><dfn>MSOutboundNetwork</dfn> contains additonal information on outbound bandwidth, in addition to the information 
provided in the <code><a>MSNetwork</a></code> base class.  
It is described in [[MS-QoE]] Section 2.2.1.5.1.

<dl class="idl" title="dictionary MSOutboundNetwork : MSNetwork">
<dt>unsigned long appliedBandwidthLimit</dt>
<dd><p>The bandwidth limit applied for sending media in bits/second.</p></dd>
<dt>unsigned long trafficShaperAverageDelay</dt>
<dd><p>Average shaper delay in ms.</p></dd>
<dt>unsigned long trafficShaperMaxDelay</dt>
<dd><p>Maximum shaper delay in ms.</p></dd>
<dt>float trafficShaperAverageBWUtilization</dt>
<dd><p>Shaper average bandwidth utilization, ranging from 0 to 1.</p></dd>
<dt>float trafficShaperMaxBWUtilization</dt>
<dd><p>Shaper maximum bandwidth utilization, ranging from 0 to 1.</p></dd>
<dt>MSOutboundTimeout timeout</dt>
<dd><p>Metrics relating to timeouts.</p></dd>
</dl>
</section>

<section id="mspayloadbase*">
<h3>Dictionary MSPayloadBase</h3>
<p><dfn>MSPayloadBase</dfn> is the base object containing payload information.
It is described in [[MS-QoE]] Section 2.2.1.15.
</p>

<dl class="idl" title="dictionary MSPayloadBase">
<dt>DOMString payloadDescription</dt>
<dd><p>Codec name, as specified in [[MS-SDPEXT]] Section 3.1.5.3 or [[!RFC3551]] Section 6.</p></dd>
</dl>
</section>

<section id="msaudiorecvsignal*">
<h3>Dictionary MSAudioRecvSignal</h3>
<p><dfn>MSAudioRecvSignal</dfn> contains information relating to the audio signal.  
It is described in [[MS-QoE]] Section 2.2.1.28 (Signal).
</p>

<dl class="idl" title="dictionary MSAudioRecvSignal">
<dt>float initialSignalLevelRMS</dt>
<dd><p>The root-mean-square of the received signal for the first 30 seconds of the call.</p></dd>
<dt>long recvSignalLevelCh1</dt>
<dd><p>Average energy level of received audio classified as mono speech, or left channel of stereo speech, in dB.</p></dd>
<dt>long recvNoiseLevelCh1</dt>
<dd><p>Average energy level of received audio classified as noise, mono signal or the left channel of stereo signal, in dB.</p></dd>
<dt>float renderSignalLevel</dt>
<dd><p>Average render speech level after dynamic range compression or analog gain control is applied, in dBo.</p></dd>
<dt>float renderNoiseLevel</dt>
<dd><p>Average render noise level after dynamic range compression or analog gain control is applied, in dBo.</p></dd>
<dt>float renderLoopbackSignalLevel</dt>
<dd><p>Average level of speaker loopback signal (after any device offload effects have been applied), in dBo.</p></dd>
</dl>
</section>

<section id="msaudiosendsignal*">
<h3>Dictionary MSAudioSendSignal</h3>
<p><dfn>MSAudioSendSignal</dfn> contains information relating to the audio signal being sent.
It is described in [[MS-QoE]] Section 2.2.1.28.
</p>

<dl class="idl" title="dictionary MSAudioSendSignal">
<dt>long noiseLevel</dt>
<dd><p>The average energy level of received or sent audio classifed as noise, in dB.</p></dd>
<dt>long sendSignalLevelCh1</dt>
<dd><p>Average energy level of sent audio classified as mono speech, or left channel of stereo speech, in dB.</p></dd>
<dt>long sendNoiseLevelCh1</dt>
<dd><p>Average noise level of sent audio classified as mono speech, or left channel of stereo speech.</p></dd>
</dl>
</section>

<section id="msaudiosendpayload*">
<h3>Dictionary MSAudioSendPayload</h3>
<p><dfn>MSAudioSendPayload</dfn> contains information relating to audio payloads being sent.
It is described in [[MS-QoE]] Section 2.2.1.14.
</p>

<dl class="idl" title="typedef (MSVideoSendPayload or MSAudioSendPayload) MSOutboundPayload">
</dl>

<dl class="idl" title="dictionary MSAudioSendPayload : MSPayloadBase">
<dt>unsigned long samplingRate</dt>
<dd><p>Audio sample rate in samples/second.</p></dd>
<dt>MSAudioSendSignal signal</dt>
<dd><p>Information relating to the audio signal being sent.</p></dd>
<dt>boolean audioFECUsed</dt>
<dd><p>"True" means that audio forward error correction (FEC) was used at some point during the call.  "False" means that no audio FEC was used during the call.  Described in [[MS-QoE] Section 2.2.1.14.1.</p></dd>
<dt>float sendMutePercent</dt>
<dd><p>Percent of session duration where the client was muted. Ranges from 0. to 100. Described in [[MS-QoE]] Section 2.2.1.14.1.</p></dd>
<dt>float deviceCaptureMuteEventRatio</dt>
<dd><p>Fraction of call duration during which the render device used for the session is muted at the system or session level.
Ranges from 0. to 1.</p></dd>
<dt>float speechLevelNEInput_Ch1</dt>
<dd><p>Speech level in dBFs, computed on the signal received from the capture device.</p></dd>
<dt>float speechLevelNEOutput_Ch1</dt>
<dd><p>Speech level in dBFs, computed on the signal sent out over the network.</p></dd>
<dt>float noiseLevelNEInput_Ch1</dt>
<dd><p>Noise level in dBFs, computed on the signal received from the capture device.</p></dd>
<dt>float noiseLevelNEOutput_Ch1</dt>
<dd><p>Noise level in dBFs, computed on the signal sent out over the network.</p></dd>
<dt>DOMString captureDeviceDriver</dt>
<dd><p>String containing the driver version of the capture device used for the session.</p></dd>
<dt>unsigned long long captureDeviceFirstDeviceStartDelay</dt>
<dd><p>Time taken to open the capture device used for the session, in 100ns.</p></dd>
<dt>unsigned long sendFECRedundancyPercent</dt>
<dd><p>Percent of the time that FEC data was received.  Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentPtime20Ms</dt>
<dd><p>Percent of time 20ms packets were used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentPtime40Ms</dt>
<dd><p>Percent of time 40ms packets were used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentPtime60Ms</dt>
<dd><p>Percent of time 60ms packets were used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentPtime100MsAndOver</dt><
<dd><p>Percent of time 100ms or higher packets were used. Ranges from 0 to 100./p></dd>
<dt>octet mostUsedCodec</dt>
<dd><p>Payload type of the most frequently used codec.</p></dd>
<dt>unsigned long percentMostUsedCodec</dt>
<dd><p>Percent of the time most frequently used codec is used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long averageBWForMostUsedCodec</dt>
<dd><p>Average bandwidth for the most frequently used codec in bits/second.</p></dd>
<dt>octet secondMostUsedCodec</dt>
<dd><p>Payload type of the second most frequently used codec.</p></dd>
<dt>unsigned long percentSecondMostUsedCodec</dt>
<dd><p>Percent of the time second most frequently used codec is used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long averageBWForSecondMostUsedCodec</dt>
<dd><p>Average bandwidth for the second most frequently used codec in bits/second.</p></dd>
<dt>octet thirdMostUsedCodec</dt>
<dd><p>Payload type of the third most frequently used codec.</p></dd>
<dt>unsigned long percentThirdMostUsedCodec</dt>
<dd><p>Percent of the time third most frequently used codec is used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long averageBWForThirdMostUsedCodec</dt>
<dd><p>Average bandwidth for the third most frequently used codec in bits/second.</p></dd>
<dt>unsigned long countOfCaptureDeviceEffectsChanged</dt>
<dd><p>Count of events for capture device effects changing.</p></dd>
<dt>unsigned long long durationOfFramesCaptured</dt>
<dd><p>Duration of real frames captured from latest active device, in ms.</p></dd>
<dt>unsigned long long durationOfCaptureDeviceActive</dt>
<dd><p>Duration from latest active capture device start to stop, in ms.</p></dd>
<dt>float deviceSpeakWhileMutedEventRatio</dt>
<dd><p>Ratio of call duration where the user was muted by the application but the
capture device reported speech activity.</p></dd>
<dt>DOMString audioCaptureDeviceInUse</dt>
<dd><p>String containing the properties of the capture device used for the session.  Metric is reported
in this format: "Form Factor; Interface Type; Product Id; Vendor Id; Device Name".</p></dd>
<dt>unsigned long numberOfChannelSwitchesNEInput</dt>
<dd><p>Number of times the microphone selection switched between the right/left channels.</p></dd>
</dl>
</section>

<section id="msvideoresolutiondistribution*">
<h3>Dictionary MSVideoResolutionDistribution</h3>
<p><dfn>MSVideoResolutionDistribution</dfn> contains metrics representing the distribution of video resolutions. 
It is described in [[MS-QoE]] Section 2.2.1.17.
</p>

<dl class="idl" title="dictionary MSVideoResolutionDistribution">
<dt>unsigned long cifQuality</dt>
<dd><p>The percentage of the duration of a call that is using the CIF resolution (0-100).</p></dd>
<dt>unsigned long vgaQuality</dt>
<dd><p>The percentage of the duration of the call that is using the VGA resolution (0-100).</p></dd>
<dt>unsigned long h720Quality</dt>
<dd><p>The percentage of the duration of the call that is using the HD720 resolution (0-100).</p></dd>
<dt>unsigned long h1080Quality</dt>
<dd><p>The percentage of the duration of the call that is using the HD1080 resolution (0-100).</p></dd>
<dt>unsigned long h1440Quality</dt>
<dd><p>The percentage of the duration of the call that is using the HD1440 resolution (0-100).</p></dd>
<dt>unsigned long h2160Quality</dt>
<dd><p>The percentage of the duration of the call that is using the HD2160 resolution (0-100).</p></dd>
</dl>
</section>

<section id="msvideopayload*">
<h3>Dictionary MSVideoPayload</h3>
<p><dfn>MSVideoPayload</dfn> contains information about video-based payload metrics. 
It is described in [[MS-QoE]] Section 2.2.1.15.
</p>

<dl class="idl" title="dictionary MSVideoPayload : MSPayloadBase">
<dt>DOMString resolution</dt>
<dd><p>Report video resolution in pixels, in the string format of Width x Height without spaces, for example "640x480".</p></dd>
<dt>unsigned long videoBitRateAvg</dt>
<dd><p>Average bit rate, or bits per second, sent or received for a video stream, computed over the duration of the session.  This includes raw video and transport bits.</p></dd>
<dt>unsigned long videoBitRateMax</dt>
<dd><p>Maximum bit rate, or bits per second, sent or received for a video stream, computed over the duration of the session.</p></dd>
<dt>float videoFrameRateAvg</dt>
<dd><p>Average frames per second sent or received for a video stream, computed over the duration of the session.</p></dd>
<dt>float videoPacketLossRate</dt>
<dd><p>The average fraction lost, as specified in [[!RFC3550]] Section 6.4.1, computed over the duration fo the session.</p></dd>
<dt>float durationSeconds</dt>
<dd><p>The received video aggregated total duration in seconds.  Defined in [[MS-QoE]] on page 128.</p></dd>
</dl>
</section>

<section id="msvideosendpayload*">
<h3>Dictionary MSVideoSendPayload</h3>
<p><dfn>MSVideoSendPayload</dfn> contains information relating to video-based payload metrics.
It is defined in [[MS-QoE]] Section Section 2.2.1.15.
</p>

<dl class="idl" title="dictionary MSVideoSendPayload : MSVideoPayload">
<dt>float sendFrameRateAverage</dt>
<dd><p>Average frames per second sent for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long sendBitRateMaximum</dt>
<dd><p>The maximum bandwidth actually sent for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long sendBitRateAverage</dt>
<dd><p>The average bandwidth actually sent for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long sendVideoStreamsMax</dt>
<dd><p>The maximum number of video streams, active during any one second interval, computed over the duration of the session.</p></dd>
<dt>unsigned long sendResolutionWidth</dt>
<dd><p>The maximum video image width received for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long sendResolutionHeight</dt>
<dd><p>The maximum video image height sent for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long cameraWidth</dt>
<dd><p>The width of the resolution that the camera is opened at.</p></dd>
<dt>unsigned long cameraHeight</dt>
<dd><p>The height of the resolution that the camera is opened at.</p></dd>
<dt>float cameraFramerate</dt>
<dd><p>Average framerate from the camera, in frames per second.</p></dd>
<dt>unsigned long videoDelayAvg</dt>
<dd><p>Delay of the video send pipeline from device to network, in ms.</p></dd>
<dt>float videoPauseEncoderCount</dt>
<dd><p>Number of video encoder pauses per minute.</p></dd>
<dt>DOMString gfxDriver</dt>
<dd><p>Graphic driver version in the format AA.BB.CCC.DDDD</p></dd>
<dt>unsigned long hwFlags</dt>
<dd><p>Bitmap with Bit 0-1: 0, Bit 2: 1 if HW encoder is supported and 0 otherwise,
Bit 3: 1 if HW encoder is blacklisted and 0 otherwise.</p></dd>
<dt>unsigned long cameraFreezePeriodCount</dt>
<dd><p>Count of 1 second intervals with no video from the camera.</p></dd>
<dt>unsigned long cameraWrongFormatFramesCount</dt>
<dd><p>Count of frames discarded due to an unexpected format.</p></dd>
</dl>
</section>

<section id="msiceaddrtype*">
<h3>Enum MSIceAddrType</h3>
<p><dfn>MSIceAddrType</dfn> describes how an ICE candidate was obtained.</p>
<dl class="idl" title="enum MSIceAddrType">
<dt>os</dt>
<dd><p>A host candidate.</p></dd>

<dt>stun</dt>
<dd><p>A server-reflexive candidate.</p></dd>

<dt>turn</dt>
<dd><p>A relay candidate.</p></dd>

<dt>uPnP</dt>
<dd><p>A candidate obtained via uPnP.  This candidate type is not supported in Microsoft Edge.</p></dd>

<dt>isa-proxy</dt>
<dd><p>A candidate obtained via an ISA proxy.  This candidate type is not supported in Microsoft Edge.</p></dd>

<dt>peer-derived</dt>
<dd><p>A peer-reflexive candidate.</p></dd>
</dl>
</section>

<section id="msnetworkinterfacetype*">
<h3>Dictionary MSNetworkInterfaceType</h3>
<p><dfn>MSNetworkInterfaceType</dfn> contains information on interface types disabled by browser privacy policy.
</p>

<dl class="idl" title="dictionary MSNetworkInterfaceType">
<dt>boolean interfaceTypeEthernet</dt>
<dd><p>An interface identified as "Ethernet" by the operating system.</p></dd>
<dt>boolean interfaceTypeWireless</dt>
<dd><p>An IEEE 802.11 interface.</p></dd>
<dt>boolean interfaceTypePPP</dt>
<dd><p>A PPP interface (dialup, PPPoE or VPN).</p></dd>
<dt>boolean interfaceTypeTunnel</dt>
<dd><p>A Tunnel interface (e.g. VPN or IPv6 tunnels).</p></dd>
<dt>boolean interfaceTypeWWAN</dt>
<dd><p>A wireless WWAN interface.</p></dd>
</dl>
</section>

<section id="mstransportdiagnosticsstats*">
<h3>Dictionary MSTransportDiagnosticsStats</h3>
<p><dfn>MSTransportDiagnosticsStats</dfn> contains metrics relating to connectivity.</p>

<dl class="idl" title="dictionary MSTransportDiagnosticsStats">
<dt>DOMString baseAddress</dt>
<dd><p>Local IP address of interface used for allocating relay candidates.</p></dd>
<dt>DOMString localAddress</dt>
<dd><p>Local interface IP address used for media flow at end of connectivity checks.</p></dd>
<dt>DOMString localSite</dt>
<dd><p>Field identifies the location of the user.  If relay allocations are successful this field will hold the server reflexive address IP.
(external NAT mapped address).  If not one of the local interface IP address.</p></dd>
<dt>DOMString networkName</dt>
<dd><p>Network name that the user endpoint is connected to.</p></dd>
<dt>DOMString remoteAddress</dt>
<dd><p>IP address of remote endpoint to which media will be sent at
end of connectivity checks.</p></dd>
<dt>DOMString remoteSite</dt>
<dd><p>Field identifies the location of the remote endpoint.  If relay allocations are
successful this field will hold the server reflexive address IP.  (external NAT mapped address) If not one of the
remote local interface IP address.</p></dd>
<dt>DOMString localMR</dt>
<dd><p>If local relay allocation is successful this field will hold the IP address of the media relay
allocated candidate.  If relay allocation has failed, this field will hold the address of the
configured media relay server.</p></dd>
<dt>DOMString remoteMR</dt>
<dd><p>IP address of the TURN candidate gathered by the remote endpoint.</p></dd>
<dt>MSIceWarningFlags iceWarningFlags</dt>
<dd><p>Flags for diagnosing connectivity failures.</p></dd>
<dt>unsigned short portRangeMin</dt>
<dd><p>Lowest port that will be used for the media sessions.</p></dd>
<dt>unsigned short portRangeMax</dt>
<dd><p>Highest port that will be used for the media sessions.</p></dd>
<dt>unsigned short localMRTCPPort</dt>
<dd><p>Allocated TCP port on the media relay server.</p></dd>
<dt>unsigned short remoteMRTCPPort</dt>
<dd><p>Allocated TCP port on the media relay server of the peer endpoint.</p></dd>
<dt>unsigned long stunVer</dt>
<dd><p>Version of STUN selected for connectivity checks.</p></dd>
<dt>unsigned long numConsentReqSent</dt>
<dd><p>Number of ICE consent requests sent.</p></dd>
<dt>unsigned long numConsentReqReceived</dt>
<dd><p>Number of ICE consent requests received.</p></dd>
<dt>unsigned long numConsentRespSent</dt>
<dd><p>Number of ICE consent responses sent.</p></dd>
<dt>unsigned long numConsentRespReceived</dt>
<dd><p>Number of ICE consent responses received.</p></dd>
<dt>MSNetworkInterfaceType interfaces</dt>
<dd><p>Interface types available and used for connectivity checks.</p></dd>
<dt>MSNetworkInterfaceType baseInterface</dt>
<dd><p>Interface type used for allocating relay candidates.</p></dd>
<dt>RTCIceProtocol protocol</dt>
<dd><p>Protocol used for media flow.</p></dd>
<dt>MSNetworkInterfaceType localInterface</dt>
<dd><p>Local interface type selected for media flow at end of connectivity checks.</p></dd>
<dt>MSIceAddrType localAddrType</dt>
<dd><p>Candidate type used for media flow at end of connectivity checks.</p></dd>
<dt>MSIceAddrType remoteAddrType</dt>
<dd><p>Candidate type of remote endpoint selected by connectivity checks.</p></dd>
<dt>RTCIceRole iceRole</dt>
<dd><p>ICE role for connectivity checks.</p></dd>
<dt>boolean rtpRtcpMux</dt>
<dd><p>Whether RTP/RTCP mux is in use.  1=> enabled.</p></dd>
<dt>unsigned long allocationTimeInMs</dt>
<dd><p>The time elapsed in ICE candidate allocation, in ms.</p></dd>
<dt>DOMString msRtcEngineVersion</dt>
<dd><p>The version of the RTC Engine in use.</p></dd>
<dt>unsigned long consentFail</dt>
<dd><p>Time since ICE initialization when a failure of ICE consent was detected, in ms.</p></dd>
<dt>MSIceConnectivityCheckStatus iceCheckStatus</dt>
<dd><p>ICE connectivity check status as reported by the transport.</p></dd>
<dt>unsigned long lastConsentRequestRecvd</dt>
<dd><p>Time since ICE initialization when the last consent request was received, in ms.</p></dd>
<dt>unsigned long long iceInitTimestamp</dt>
<dd><p>Time since the reference time (midnight UTC (00:00) on January 1, 1900) when ICE was initialized, in ms.</p></dd>
<dt>unsigned long long blobGenTime</dt>
<dd><p>Time since the reference time (midnight UTC (00:00) on January 1, 1900) at which the blob was generated, in ms.</p></dd>
</dl>
</section>
	
<section id="msiceconnectivitycheckstatus*">
<h3>Enum MSIceConnectivityCheckStatus</h4>
<p><dfn>MSIceConnectivityCheckStatus</dfn> provides information on the status of ICE connectivity checks.</p>
<dl class="idl" title="enum MSIceConnectivityCheckStatus">
<dt>not-started</dt>
<dd><p>Connectivity checks have not started.</p></dd>
<dt>preliminary-checks-succeeded</dt>
<dd><p>Preliminary connectivity checks have succeeded.</p></dd>
<dt>preliminary-checks-failed</dt>
<dd><p>Preliminary connectivity checks have failed.</p></dd>
<dt>in-progress</dt>
<dd><p>Connectivity checks are in progress.</p></dd>
<dt>succeeded</dt>
<dd><p>Connectivity checks have succeeded.</p></dd>
<dt>failed</dt>
<dd><p>Connectivity checks have failed.</p></dd>
</dl>
</section>

<section id="msaudiorecvpayload*">
<h3>Dictionary MSAudioRecvPayload</h3>
<p><dfn>MSAudioRecvPayload</dfn> contains information relating to audio reception. 
It is defined in [[MS-QoE]] Section 2.2.1.14.
</p>

<dl class="idl" title="typedef (MSVideoRecvPayload or MSAudioRecvPayload) MSInboundPayload">
</dl>

<dl class="idl" title="dictionary MSAudioRecvPayload : MSPayloadBase">
<dt>unsigned long samplingRate</dt>
<dd><p>Samples per second.</p></dd>
<dt>MSAudioRecvSignal signal</dt>
<dd><p>Metrics regarding signal level and noise.</p></dd>
<dt>float packetReorderRatio</dt>
<dd><p>Ratio of packets received that were out of sequence during the session.</p></dd>
<dt>long packetReorderDepthAvg</dt>
<dd><p>Average of the number of packets between when the current packet and the out-of-sequence packet was received.</p></dd>
<dt>long packetReorderDepthMax</dt>
<dd><p>Maximum of the number of packets between when the current packet and the out-of-sequence packet was received.</p></dd>
<dt>float burstLossLength1</dt>
<dd><p>Ratio of lost single lost packet over the total number of packets for the session.</p></dd>
<dt>float burstLossLength2</dt>
<dd><p>Ratio of two consecutive lost packets over the total number of packets for the session.</p></dd>
<dt>float burstLossLength3</dt>
<dd><p>Ratio of three consecutive lost packets over the total number of packets for the session.</p></dd>
<dt>float burstLossLength4</dt>
<dd><p>Ratio of four consecutive lost packets over the total number of packets for the session.</p></dd>
<dt>float burstLossLength5</dt>
<dd><p>Ratio of five consecutive lost packets over the total number of packets for the session.</p></dd>
<dt>float burstLossLength6</dt>
<dd><p>Ratio of six consecutive lost packets over the total number of packets for the session.</p></dd>
<dt>float burstLossLength7</dt>
<dd><p>Ratio of seven consecutive lost packets over the total number of packets for the session.</p></dd>
<dt>float burstLossLength8OrHigher</dt>
<dd><p>Ratio of eight or more consecutive lost packets over the total number of packets for the session.</p></dd>
<dt>float fecRecvDistance1</dt>
<dd><p>Percentage of session where packets with FEC distance of 1 were received.</p></dd>
<dt>float fecRecvDistance2</dt>
<dd><p>Percentage of session where packets with FEC distance of 2 were received.</p></dd>
<dt>float fecRecvDistance3</dt>
<dd><p>Percentage of session where packets with FEC distance of 3 were received.</p></dd>
<dt>float ratioConcealedSamplesAvg</dt>
<dd><p>Ratio of the number of audio frames with samples generated by packet loss concealment to the total number of audio frames.  Described in [[MS-QoE]] Section 2.2.1.12.1.</p></dd>
<dt>float ratioStretchedSamplesAvg</dt>
<dd><p>Ratio of the number of audio frames with samples that have been stretched to compensate for jitter or loss to the total number of audio frames.  Described in [[MS-QoE]] Section 2.2.1.12.1.</p></dd>
<dt>float ratioCompressedSamplesAvg</dt>
<dd><p>Ratio of the number of audio frames with samples that have been compressed to compensate for jitter or loss to the total number of audio frames.  Described in [[MS-QoE]] Section 2.2.1.12.1.</p></dd>
<dt>float speechLevelFEInput_Ch1</dt>
<dd><p>Speech level in dBFs, computed on the signal received over the network.</p></dd>
<dt>float speechLevelFEOutput_Ch1</dt>
<dd><p>Speech level in dBFs, computed on the signal from the application to the render device.</p></dd>
<dt>float speechLevelLBInput_Ch1</dt>
<dd><p>Speech level in dBFs, computed on the signal being rendered by the host machine to the render device.</p></dd>
<dt>float noiseLevelFEInput_Ch1</dt>
<dd><p>Noise level in dBFs, computed on the signal received over the network.</p></dd>
<dt>float noiseLevelFEOutput_Ch1</dt>
<dd><p>Noise level in dBFs, computed on the signal from the application to the render device.</p></dd>
<dt>float noiseLevelLBInput_Ch1</dt>
<dd><p>Noise level in dBFs, computed on the signal rendered by the host machine to the render device.</p></dd>
<dt>DOMString renderDeviceDriver</dt>
<dd><p>String containing the driver version of the render device used for the session.</p></dd>
<dt>unsigned long fecRecvOnPercent</dt>
<dd><p>Percent of the time that FEC data was received. Ranges from 0 to 100./p></dd>
<dt>unsigned long percentTimeInGoodNWState</dt>
<dd><p>Percent of the time network conditions were good. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentTimeInPoorNWState</dt>
<dd><p>Percent of the time network conditions were poor. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentTimeInBadNWState</dt>
<dd><p>Percent of the time network conditions were bad. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentTimeInCatastrophicNWState</dt>
<dd><p>Percent of the time network conditions were catastrophic. Ranges from 0 to 100.</p></dd>
<dt>unsigned long jitterBufferSizeAverage</dt>
<dd><p>Average jitter buffer size, in ms.</p></dd>
<dt>unsigned long jitterBufferSizeMaximum</dt>
<dd><p>Maximum jitter buffer size, in ms.</p></dd>
<dt>unsigned long jitterBufferSizeSD</dt>
<dd><p>Standard deviation of jitter buffer size, in ms.</p></dd>
<dt>unsigned long networkJitterAverage</dt>
<dd><p>Average network jitter, in ms.</p></dd>
<dt>unsigned long networkJitterMaximum</dt>
<dd><p>Maximum network jitter, in ms.</p></dd>
<dt>unsigned long networkJitterSD</dt>
<dd><p>Standard deviation of network jitter, in ms.</p></dd>
<dt>unsigned long percentPtime20Ms</dt>
<dd><p>Percent of time 20ms packets were used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentPtime40Ms</dt>
<dd><p>Percent of time 40ms packets were used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentPtime60Ms</dt>
<dd><p>Percent of time 60ms packets were used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long percentPtime100MsAndOver</dt>
<dd><p>Percent of time 100ms or higher packets were used. Ranges from 0 to 100.</p></dd>
<dt>octet mostUsedCodec</dt>
<dd><p>Payload type of the most frequently used codec.</p></dd>
<dt>unsigned long percentMostUsedCodec</dt>
<dd><p>Percent of the time most frequently used codec is used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long averageBWForMostUsedCodec</dt>
<dd><p>Average bandwidth for the most frequently used codec in bits/second.</p></dd>
<dt>octet secondMostUsedCodec</dt>
<dd><p>Payload type of the second most frequently used codec.</p></dd>
<dt>unsigned long percentSecondMostUsedCodec</dt>
<dd><p>Percent of the time second most frequently used codec is used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long averageBWForSecondMostUsedCodec</dt>
<dd><p>Average bandwidth for the second most frequently used codec in bits/second.</p></dd>
<dt>octet thirdMostUsedCodec</dt>
<dd><p>Payload type of the third most frequently used codec.</p></dd>
<dt>unsigned long percentThirdMostUsedCodec</dt>
<dd><p>Percent of the time third most frequently used codec is used. Ranges from 0 to 100.</p></dd>
<dt>unsigned long averageBWForThirdMostUsedCodec</dt>
<dd><p>Average bandwidth for the third most frequently used codec in bits/second.</p></dd>
<dt>unsigned long countOfRenderDeviceEffectsChanged</dt>
<dd><p>Count of events for render device effects changing.</p></dd>
<dt>unsigned long long durationOfFramesRendered</dt>
<dd><p>Duration of real frames rendered to latest active device, in ms.</p></dd>
<dt>unsigned long long durationOfRenderDeviceActive</dt>
<dd><p>Duration from latest active render device start to stop, in ms.</p></dd>
<dt>unsigned long long durationOfLoopbackFramesCaptured</dt>
<dd><p>Duration of real frames captured from latest active loopback device, in ms.</p></dd>
<dt>unsigned long long durationOfLoopbackDeviceActive</dt>
<dd><p>Duration from latest active loopback device start to stop, in ms.</p></dd>
<dt>unsigned long long renderDeviceFirstDeviceStartDelay</dt>
<dd><p>Time taken to open the capture device used for the session, in 100ns.</p></dd>
</dl>
</section>

<section id="msvideorecvpayload*">
<h3>Dictionary MSVideoRecvPayload</h3>
<p><dfn>MSVideoRecvPayload</dfn> contains information relating to incoming video.  
It is defined in [[MS-QoE]] Section 2.2.1.15.1.
</p>

<dl class="idl" title="dictionary MSVideoRecvPayload : MSVideoPayload">
<dt>float videoFrameLossRate</dt>
<dd><p>The average fraction of frames lost on the video receiver side, computer of the duration of the session.</p></dd>
<dt>DOMString recvCodecType</dt>
<dd><p>Codec name, as specified in [[MS-SDPEXT]] Section 3.1.5.3 or [[!RFC3551]] Section 6 concatenated by resource type.  See [[MS-QoE]] Section 2.2.1.15.1.2.</p></dd>
<dt>unsigned long recvResolutionWidth</dt>
<dd><p>The maximum video image width received for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long recvResolutionHeight</dt>
<dd><p>The maximum video image height received for all video streams, computed over the duration of the session.</p></dd>
<dt>MSVideoResolutionDistribution videoResolutions</dt>
<dd><p>Metrics representing the distribution of video resolutions.</p></dd>
<dt>float recvFrameRateAverage</dt>
<dd><p>Average frames per second received for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long recvBitRateMaximum</dt>
<dd><p>The maximum bandwidth received for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long recvBitRateAverage</dt>
<dd><p>The average bandwidth received for all video streams, computed over the duration of the session.</p></dd>
<dt>unsigned long recvVideoStreamsMax</dt>
<dd><p>The maximum number of video streams received during any one second interval, computed over the duration of the session.</p></dd>
<dt>unsigned long recvVideoStreamsMin</dt>
<dd><p>The minimum number of video streams received during any one second interval, computed over the duration of the session.</p></dd>
<dt>long recvVideoStreamsMode</dt>
<dd><p>The most common number ("mode") of video streams received during any one second interval, computed over the duration of the session.</p></dd>
<dt>float videoPostFECPLR</dt>
<dd><p>Reports packet loss rate after FEC has been applied for video.  Aggregated across all video streams and codecs.  Value between 0.00 and 1.00.</p></dd>
<dt>float lowBitRateCallPercent</dt>
<dd><p>Percentage of time of the call where bit rate is 70 kilobits per second or less.</p></dd>
<dt>float lowFrameRateCallPercent</dt>
<dd><p>Percentage of time of the call where frame rate is less than 7.5 frames per second.</p></dd>
<dt>unsigned long reorderBufferTotalPackets</dt>
<dd><p></p></dd>
<dt>unsigned long recvReorderBufferReorderedPackets</dt>
<dd><p>The number of reordered video packets.</p></dd>
<dt>unsigned long recvReorderBufferPacketsDroppedDueToBufferExhaustion</dt>
<dd><p>The number of video packets dropped due to buffer exhaustion.</p></dd>
<dt>unsigned long recvReorderBufferMaxSuccessfullyOrderedExtent</dt>
<dd><p>The maximum reorder extent in the case where video packets arrive late and FEC has already recovered this packet.</p></dd>
<dt>unsigned long recvReorderBufferMaxSuccessfullyOrderedLateTime</dt>
<dd><p>The maximum late time in the case where video packets arrive late and FEC has already recovered this packet.</p></dd>
<dt>unsigned long recvReorderBufferPacketsDroppedDueToTimeout</dt>
<dd><p>The number of video packets dropped due to time out as they arrive late.</p></dd>
<dt>float recvFpsHarmonicAverage</dt>
<dd><p>Calculated received FPS using harmonic average.</p></dd>
<dt>float recvNumResSwitches</dt>
<dd><p>How many times the receiver sees a resolution change.</p></dd>
<dt>float recvBaseLayerQpAvg</dt>
<dd><p>Average Quantization Parameter (QP) of the received base layer frames.</p></dd>
<dt>unsigned long recvAvgFreezeDuration</dt>
<dd><p>Average size of an individual freeze for this incoming stream, in ms.</p></dd>
<dt>unsigned long recvIdrRecoveryCount</dt>
<dd><p>Number of IDR recoveries received.</p></dd>
<dt>float recvCapabilityNumViewsAverage</dt>
<dd><p>Average number of views decided by the capability of the machine.</p></dd>
<dt>float recvBandwidthNumViewsAverage</dt>
<dd><p>Average number of views decided by bandwidth estimation.</p></dd>
<dt>long recvAVSyncDistanceAvg</dt>
<dd><p>Average sync of the receive stream in ms (audio delay minus video delay).</p></dd>
<dt>long recvAVSyncDistanceCur</dt>
<dd><p>Average audio/video sync of the receive stream for the last 10 seconds, in ms (audio delay minus video delay).</p></dd>
<dt>unsigned long recvNormalizedFreezeDuration</dt>
<dd><p>Freeze of video per minute of the receive stream as a percentage (0-100).</p></dd>
</dl>
</section>
</section>
</section>
<section class="informative">
<h2>Event summary</h2>

<p>The following events fire on <code><a>RTCDtlsTransport</a></code>
objects:</p>

<table border="1" style="border-width:0; width:60%">
<tr>
<th>Event name</th>
<th>Interface</th>
<th>Fired when...</th>
</tr>
<tbody>
<tr>
  <td><code>error</code></td>
  <td><code><a>Event</a></code>
  </td>

  <td>The <code><a>RTCDtlsTransport</a></code> object has
  received a DTLS Alert.</td>
</tr>
<tr>
  <td><code>dtlsstatechange</code></td>
  <td><code><a>RTCDtlsTransportStateChangedEvent</a></code>
  </td>
  <td>The <var>RTCDtlsTransportState</var> changed.</td>
</tr>
</tbody>
</table>

    <p>The following event fires on <code><a>RTCSrtpSdesTransport</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>Event</a></code>
          </td>

          <td>The <code><a>RTCSrtpSdesTransport</a></code> object has
          encountered an error.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCIceTransport</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>icestatechange</code></td>
          <td><code><a>RTCIceTransportStateChangedEvent</a></code>
          </td>
          <td>The <var>RTCIceTransportState</var> changed.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCIceGatherer</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>Event</a></code>
          </td>
          <td>The <code><a>RTCIceGatherer</a></code> object has
          experienced an ICE gathering failure (such as an authentication failure with TURN credentials).</td>
        </tr>
        <tr>
          <td><code>icecandidate</code></td>
          <td><code><a>RTCIceGatherer</a></code>
          </td>
          <td>A new <code><a>RTCIceGatherCandidate</a></code> is made available to the script.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCRtpSender</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>Event</a></code>
          </td>
          <td>An error has been detected within the <code><a>RTCRtpSender</a></code> object.
         This is not used for programmatic exceptions.</td>
        </tr>
      </tbody>
    </table>

    <p>The following event fires on <code><a>RTCRtpReceiver</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>Event</a></code>
          </td>
          <td>An error has been detected within the <code><a>RTCRtpReceiver</a></code> object,
          such as an issue with <code><a>RTCRtpParameters</a></code> that could not be detected
          until media arrival.   
          This is not used for programmatic exceptions.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCDTMFSender</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><dfn id=
          "event-RTCDTMFSender-tonechange"><code>tonechange</code></dfn>
          </td>

          <td><code><a>Event</a></code>
          </td>

          <td>The <code><a>RTCDTMFSender</a></code> object has either just
          begun playout of a tone (returned as the <code><a>tone</a></code>
          attribute) or just ended playout of a tone (returned as an empty
          value in the <code><a>tone</a></code> attribute).</td>
        </tr>
      </tbody>
    </table>
</section>

<section class="informative" id="error-codes*">
<h2>Error codes</h2>

<p>Below is a table of Edge ORTC API error codes and their meanings.</p>


    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Error Code</th>
        <th>Mnemonic</th>
        <th>Meaning</th>
      </tr>
      <tbody>
        <tr>
          <td>0xC004E001L</td>
          <td>E_ORTC_INVALID_ARGUMENT</td>
          <td>Invalid argument</td>
        </tr>
        <tr>
          <td>0xC004E002L</td>
          <td>E_ORTC_NO_INTERFACE</td>
          <td>Couldn't find matching interface</td>
        </tr>
        <tr>
          <td>0xC004E003L</td>
          <td>E_ORTC_OUT_OF_MEMORY</td>
          <td>Out of memory</td>
        </tr>
        <tr>
          <td>0xC004E004L</td>
          <td>E_ORTC_DEVICE_ENUMERATION</td>
          <td>Device enumeration failed</td>
        </tr>
        <tr>
          <td>0xC004E005L</td>
          <td>E_ORTC_INVALID_STATE</td>
          <td>Invalid state</td>
        </tr>
        <tr>
          <td>0xC004E006L</td>
          <td>E_ORTC_DEVICE_NOT_READY</td>
          <td>Device is not ready</td>
        </tr>
        <tr>
          <td>0xC004E007L</td>
          <td>E_ORTC_CHANNEL_UNAVAILABLE</td>
          <td>Channel is not available</td>
        </tr>
        <tr>
          <td>0xC004E008L</td>
          <td>E_ORTC_UNKNOWN_CODEC</td>
          <td>Unknown codec</td>
        </tr>
        <tr>
          <td>0xC004E009L</td>
          <td>E_ORTC_UNKNOWN_MEDIA_KIND</td>
          <td>Unknown media kind</td>
        </tr>
        <tr>
          <td>0xC004E00AL</td>
          <td>E_ORTC_DEVICE_INIT</td>
          <td>Device initialization failed</td>
        </tr>
        <tr>
          <td>0xC004E00BL</td>
          <td>E_ORTC_CRYPTO</td>
          <td>Invalid crypto parameters</td>
        </tr>
        <tr>
          <td>0xC004E00CL</td>
          <td>E_ORTC_NOT_IMPLEMENTED</td>
          <td>Not implemented</td>
        </tr>
        <tr>
          <td>0xC004E00DL</td>
          <td>E_ORTC_RTP_PARAMETER</td>
          <td>Invalid RTP parameters</td>
        </tr>
        <tr>
          <td>0xC004E00EL</td>
          <td>E_ORTC_ENDPOINT_ALLOCATION_FAIL</td>
          <td>Transport endpoint allocation failed</td>
        </tr>
        <tr>
          <td>0xC004E00FL</td>
          <td>E_ORTC_DTLS_HANDSHAKE_FAILED</td>
          <td>DTLS handshake failed</td>
        </tr>
      </tbody>
    </table>
</section>
<section class="informative" id="webrtc-compat*">
  <h2>WebRTC 1.0 Compatibility</h2>

<p>It is a goal of the ORTC API to provide the functionality of the WebRTC 1.0 API [[WEBRTC10]], as well as to enable the 
WebRTC 1.0 API to be implemented on top of the ORTC API, utilizing a Javascript "shim" library.  This section
discusses WebRTC 1.0 compatibility issues.
</p>

<section id="rtprtcpmux*">
   <h3>RTP/RTCP multiplexing</h3>
<p>As noted in [[!RTP-USAGE]] Section 4.5, support for RTP/RTCP multiplexing [[!RFC5761]] is mandatory-to-implement in
WebRTC.  Via the "a=rtcp-mux" line, WebRTC 1.0 implementations can negotiate RTP/RTCP multiplexing.
In ORTC API, multiplexing of RTP and RTCP [[!RFC5761]] is enabled by setting <code>RTCRtcpParameters.mux</code>
to <code>true</code> (the default) when calling <code>receiver.receive()</code> or <code>sender.send()</code>.</p>
<p>Microsoft Edge only allows a single <code><a>RTCTransport</a></code> to be specified when constructing
an <code><a>RTCRtpSender</a></code> or <code><a>RTCRtpReceiver</a></code> object.  When an <code><a>RTCDtlsTransport</a></code>
is used in the constructor, RTP/RTCP multiplexing is required.</p>
<p>Microsoft Edge supports both multiplexed and non-multiplexed RTP/RTCP with
<code><a>RTCSrtpSdesTransport</a></code> objects.
To not multiplex RTP and RTCP with an <code><a>RTCSrtpSdesTransport</a></code>,
construct an associated RTCP <code><a>RTCIceTransport</a></code> prior to constructing the <code><a>RTCSrtpSdesTransport</a></code>. 
<code>RTCRtcpParameters.mux</code> is then set to <code>false</code> when <code>receiver.receive()</code> or
<code>sender.send()</code> is called.
To configure RTP/RTCP multiplexing when constructing an <code><a>RTCSrtpSdesTransport</a></code>,
do not construct an associated RTCP <code><a>RTCIceTransport</a></code>
or if one was constructed, call <code>stop()</code> on it. 
<code>RTCRtcpParameters.mux</code> is then set to <code>true</code> when <code>receiver.receive()</code> or
<code>sender.send()</code> is called.</p>
</section>

<section id="bundle*">
  <h3>BUNDLE</h3>
<p>As noted in [[!RTP-USAGE]] Section 4.4, audio/video multiplexing is mandatory-to-implement in WebRTC, 
as described in [[!RTP-MULTI-STREAM]]. 
Via the use of [[!BUNDLE]] it is possible for WebRTC 1.0 implementations to negotiate the multiplexing of audio and 
video on the same RTP session. 
The Microsoft Edge ORTC implementation enables bundling of audio and video [[!BUNDLE]] 
by constructing multiple 
<code><a>RTCRtpReceiver</a></code> and <code><a>RTCRtpSender</a></code>
objects from the same <code><a>RTCDtlsTransport</a></code> or <code><a>RTCSrtpSdesTransport</a></code> object.</p>
</section>

<section id="voice-activity*">
  <h3>Voice Activity Detection</h3>
<p>[[WEBRTC10]] Section 4.2.4 defines the <code>RTCOfferOptions</code> dictionary, which includes the <var>voiceActivityDetection</var> attribute,
which determines whether Voice Activity Detection (VAD) is enabled within the Offer 
produced by <code>createOffer()</code>. 
The effect of setting <var>voiceActivityDetection</var> to <var>true</var> is to include the 
Comfort Noice (CN) codec defined in [[!RFC3389]] within the Offer.</p>
<p>Within ORTC API, equivalent behavior can be obtained by configuring the 
Comfort Noise (CN) codec within <code>RTCRtpParameters</code>.  Relevant considerations are described in Section 8.3.2.3.
Currently, the Microsoft Edge implementations of SILK and Opus do not support Discontinuous Operation (DTX).</p>
</section>
<section id="h264*">
              <h3>H.264/AVC</h3>
              <p>
                   [[RFC6184]] Section 8.1 defines the <code>level-asymmetry-allowed</code> SDP parameter
                   supported by some WebRTC 1.0 API implementations. Within  ORTC API, the <code>profileLevelId</code>
                   capability is supported for both the <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code>,
                   and the <code>profileLevelId</code> setting is provided for the <code><a>RTCRtpSender</a></code>.
                   Since in ORTC API sender and receiver <code>profileLevelId</code> capabilities are independent
                   and there is no <code>profileLevelId</code> setting for an <code><a>RTCRtpReceiver</a></code>,
                   ORTC API assumes that implementations support level asymmetry.  Therefore a WebRTC 1.0 API shim library
                   for ORTC API should provide a <code>level-asymmetry-allowed</code> value of <code>1</code>.
               </p>
           </section>
</section>
<section class="informative" id="examples*">
  <h2>Examples</h2>

  <section id="simple-peer-to-peer-example*">
    <h3>Simple Peer-to-peer Example</h3>

    <p>This example code provides a basic audio and video session between two browsers.</p>

   <pre xml:space="preserve" class='example highlight'>
   </pre>
  </section>
  <section id="js-library-example*">
    <h3>myCapsToSendParams Example</h3>


   <pre xml:space="preserve" class='example highlight'>
RTCRtpParameters function myCapsToSendParams (RTCRtpCapabilities sendCaps, RTCRtpCapabilities remoteRecvCaps) {
// Function returning the sender RTCRtpParameters, based on the local sender and remote receiver capabilities.
// The goal is to enable a single stream audio and video call with minimum fuss. 
//
// Steps to be followed: 
// 1. Determine the RTP features that the receiver and sender have in common. 
// 2. Determine the codecs that the sender and receiver have in common.
// 3. Within each common codec, determine the common formats, header extensions and rtcpFeedback mechanisms.
// 4. Determine the payloadType to be used, based on the receiver preferredPayloadType. 
// 5. Set RTCRtcpParameters such as mux to their default values.  
// 6. Return RTCRtpParameters enablig the jointly supported features and codecs.
}

RTCRtpParameters function myCapsToRecvParams (RTCRtpCapabilities recvCaps, RTCRtpCapabilities remoteSendCaps) {
// Function returning the receiver RTCRtpParameters, based on the local receiver and remote sender capabilities.
return myCapsToSendParams(remoteSendCaps, recvCaps);
}
</pre>

  </section>
</section>

  <section class="appendix">

  <h2>Acknowledgements</h2>
  <p>Microsoft acknowledges the W3C ORTC Community Group for creating the ORTC API.  We would also like to acknowledge Phillipp Hancke, who provided extensive review comments.
  </p>
  </section>

</body>
</html>
